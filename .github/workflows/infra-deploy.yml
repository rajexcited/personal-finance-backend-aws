# This workflow performs basic steps
# build, compile, synth and unit test
name: AWS Infra Deploy

on:
  issues:
    types:
      - opened

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.title }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: write
  issues: write
  pull-requests: write

jobs:
  display_output:
    name: Display Output
    runs-on: ubuntu-latest
    steps:
      # https://docs.github.com/en/webhooks/webhook-events-and-payloads#issues
      - run: |
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue id: ${{ github.event.issue.id }}"
      - run: |
          echo "Issue title: ${{ github.event.issue.title }}"
      - env:
          ISS_BODY: ${{ github.event.issue.body }}
        run: |
          echo "Issue body: $ISS_BODY"
      - run: |
          echo "Issue milestone title: ${{ github.event.issue.milestone.title }}"
          echo "Issue milestone: ${{ github.event.issue.milestone }}"
      - run: |
          echo "Issue state: ${{ github.event.issue.state }}"
          echo "Issue state reason: ${{ github.event.issue.state_reason }}"
      - run: |
          echo "Issue draft: ${{ github.event.issue.draft }}"
          echo "Issue locked: ${{ github.event.issue.locked }}"
          echo "Issue active lock reason: ${{ github.event.issue.active_lock_reason }}"
      - run: |
          echo "Issue labels name: ${{ toJson(github.event.issue.labels.*.name) }}"
      - run: |
          echo "Issue total comments: ${{ github.event.issue.comments }}"
      - run: |
          echo "Issue updated at: ${{ github.event.issue.updated_at }}"
          echo "Issue closed at: ${{ github.event.issue.closed_at }}"
          echo "Issue created at: ${{ github.event.issue.created_at }}"
      - run: |
          echo "Issue author association: ${{ github.event.issue.author_association }}"
      - run: |
          echo "Issue sender login: ${{ github.event.sender.login }}"
          echo "Issue sender type: ${{ github.event.sender.type }}"
          echo "Issue sender id: ${{ github.event.sender.id }}"
          echo "Issue sender view type: ${{ github.event.sender.user_view_type }}"
      - run: |
          echo "Issue user login: ${{ github.event.issue.user.login }}"
          echo "Issue user type: ${{ github.event.issue.user.type }}"
          echo "Issue user id: ${{ github.event.issue.user.id }}"
          echo "Issue user view type: ${{ github.event.issue.user.user_view_type }}"
      - run: |
          echo "Issue assignee login: ${{ github.event.issue.assignee.login }}"
          echo "Issue assignee type: ${{ github.event.issue.assignee.type }}"
          echo "Issue assignee id: ${{ github.event.issue.assignee.id }}"
          echo "Issue assignee view type: ${{ github.event.issue.assignee.user_view_type }}"
      - run: |
          echo "github actor: ${{ github.actor }}"
          echo "github triggering actor: ${{ github.triggering_actor }}"
          echo "Issue perfomed by app: ${{ github.event.issue.performed_via_github_app }}"
      - run: |
          echo "action: ${{ github.action }}"
          echo "event name: ${{ github.event_name }}"
          echo "event changes: ${{ github.event.changes }}"
          echo "event action: ${{ github.event.action }}"
      - env:
          GITHUB_JSON: ${{ toJson(github) }}
        run: |
          echo github json= $GITHUB_JSON
      - uses: actions/github-script@v7
        with:
          script: |
            console.log("Context obj: ", context);
            console.log("Github Apis: ", github)
            console.log("Github Rest API config: ", github.rest)
            console.log("Github Rest Repo API:", github.rest.git)
            console.log("Github Rest Issues API:", github.rest.issues)

  run_eligible:
    name: Workflow Run Eligible
    runs-on: ubuntu-latest
    outputs:
      original-issue-title: ${{ github.event.issue.title }}
      is-prod-provision: ${{ steps.request-title.outputs.is-prod-provision }}
      is-prod-rollback: ${{ steps.request-title.outputs.is-prod-rollback }}
      is-testplan-provision: ${{ steps.request-title.outputs.is-testplan-provision }}
      is-testplan-deprovision: ${{ steps.request-title.outputs.is-testplan-deprovision }}
      is-development-provision: ${{ steps.request-title.outputs.is-development-provision }}
      is-development-deprovision: ${{ steps.request-title.outputs.is-development-deprovision }}
      request-type: ${{ steps.request-title.outputs.request-type }}
      env-ref-name: ${{ steps.env-label.outputs.env-ref-name }}
      is-production: ${{ steps.env-label.outputs.for-production }}
      is-testplan: ${{ steps.env-label.outputs.for-testplan }}
      is-development: ${{ steps.env-label.outputs.for-development }}
    steps:
      - run: |
          echo "Eligibilities"
          echo "Request form is for deployment purpose"
          echo "Request form must assigned milestone"
          echo "Request form is created by owner"
          echo "Only 1 Environment must exist"
          echo "Request form is either provision or deprovision request"
      - if: >
          ! contains(github.event.issue.labels.*.name, 'deployment') ||
          ! startsWith(github.event.issue.author_association, 'OWNER') ||
          ! github.event.issue.milestone != null
        run: |
          echo Workflow is not eligible to process issue
          exit 1
      - id: env-label
        env:
          IS_PRODUCTION: "${{ contains(github.event.issue.labels.*.name, 'env: production') }}"
          IS_TESTPLAN: "${{ contains(github.event.issue.labels.*.name, 'env: testplan') }}"
          IS_DEVELOPMENT: "${{ contains(github.event.issue.labels.*.name, 'env: development') }}"
        run: |
          echo "Count the number of 'true' values"
          echo "for-production=$IS_PRODUCTION"
          echo "for-testplan=$IS_TESTPLAN"
          echo "for-development=$IS_DEVELOPMENT"
          TRUE_ENV_COUNT=0
          if [[ "$IS_PRODUCTION" == "true" ]]; then
            ((TRUE_ENV_COUNT++))
            echo "updated count for production"
            echo "env-ref-name=production" >> $GITHUB_OUTPUT
          fi
          if [[ "$IS_TESTPLAN" == "true" ]]; then
            ((TRUE_ENV_COUNT++))
            echo "updated count for testplan"
            echo "env-ref-name=testplan" >> $GITHUB_OUTPUT
          fi
          if [[ "$IS_DEVELOPMENT" == "true" ]]; then
            echo "updated count for development"
            ((TRUE_ENV_COUNT++))
            echo "env-ref-name=development" >> $GITHUB_OUTPUT
            echo "env-ref-name=development"
          fi

          # Check if only one variable is true
          if [[ "$TRUE_ENV_COUNT" -eq 0 ]]; then
            echo "no environment label is defined to issue"
            echo "Workflow is not eligible to process issue"
            exit 1
          fi
          if [[ "$TRUE_ENV_COUNT" -gt 1 ]]; then
            echo "$TRUE_ENV_COUNT environment labels are defined to issue which are more than 1"
            echo "Workflow is not eligible to process issue. ambiguous request."
            exit 1
          fi
          echo "for-production=$IS_PRODUCTION" >> $GITHUB_OUTPUT
          echo "for-testplan=$IS_TESTPLAN" >> $GITHUB_OUTPUT
          echo "for-development=$IS_DEVELOPMENT" >> $GITHUB_OUTPUT
          echo "all vars are exported"
          cat $GITHUB_OUTPUT
      - id: request-title
        uses: actions/github-script@v7
        env:
          ENV_REF_NAME: ${{ steps.env-label.outputs.env-ref-name }}
        with:
          script: |
            const environmentProvisioningMap = {
              "is-testplan-provision": false,
              "is-testplan-deprovision": false,
              "is-development-provision": false,
              "is-development-deprovision": false,
              "is-prod-provision": false,
              "is-prod-rollback": false,
            };
            let environmentProvisioningCount = 0;
            const nospaceTitle = context.payload.issue.title.replace(/\s+/g, ""); // Removes all spaces
            if(process.env.ENV_REF_NAME === "development") {
              if(nospaceTitle.startsWith("[Request]ProvisionDevelopmentEnvironment")) {
                environmentProvisioningMap["is-development-provision"] = true;
                environmentProvisioningCount++;
              } 
              if(nospaceTitle.startsWith("[Request]DeprovisionDevelopmentEnvironment")) {
                environmentProvisioningMap["is-development-deprovision"] = true;
                environmentProvisioningCount++;
              }
            }
            if(process.env.ENV_REF_NAME === "testplan") {
              if(nospaceTitle.startsWith("[Request]ProvisionTestPlanEnvironment")) {
                environmentProvisioningMap["is-testplan-provision"] = true;
                environmentProvisioningCount++;
              }
              if(nospaceTitle.startsWith("[Request]DeprovisionTestPlanEnvironment")) {
                environmentProvisioningMap["is-testplan-deprovision"] = true;
                environmentProvisioningCount++;
              }
            }
            if(process.env.ENV_REF_NAME === "production") {
              if(nospaceTitle.startsWith("[Request]ProvisionProductionEnvironment")) {
                environmentProvisioningMap["is-prod-provision"] = true;
                environmentProvisioningCount++;
              }
              if(nospaceTitle.startsWith("[Request][Rollback]ProvisionProductionEnvironment")) {
                environmentProvisioningMap["is-prod-rollback"] = true;
                environmentProvisioningCount++;
              }
            }
            if(environmentProvisioningCount !== 1) {
              const errorMessage = "The Request is not for provision or deprovision environment. Workflow is not eligible to process issue";
              core.setFailed(errorMessage);
              throw new Error(errorMessage);
            }
            Object.entries(environmentProvisioningMap).forEach(([key, value])=> {
              core.setOutput(key, `${value}`);
            });
            if(environmentProvisioningMap["is-development-deprovision"] || environmentProvisioningMap["is-testplan-deprovision"]) {
              core.setOutput("request-type", "deprovision");
            } else {
              core.setOutput("request-type", "provision");
            }

  update_request:
    name: Start Request
    runs-on: ubuntu-latest
    needs:
      - run_eligible
    outputs:
      failed-reason: ${{ steps.update-request.outputs.failedReason }}
    steps:
      - run: |
          echo "The issue has milestone assigned and locked."
          echo "The issue has required labels (deployment, test plan)."
          echo "This request form is raised by owner."
          echo "This request form title indicates that It is related to provision or deprovision test plan environment."
          echo "We will validate request form issue details."
      - id: update-request
        name: Update Issue - Start Processing
        uses: actions/github-script@v7
        env:
          ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            try {
              const updateResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Processing] " + process.env.ISSUE_TITLE
              });
              console.log("updateResponse: ", updateResponse);
              if(!context.payload.issue.locked) {
                const lockIssueResponse = await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number
                });
                console.log("Lock issue response:", lockIssueResponse);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  validate_request:
    name: Validate Request Form
    runs-on: ubuntu-latest
    environment:
      name: aws-infra-development
    needs:
      - run_eligible
      - update_request
    outputs:
      branch-name: ${{ steps.get-milestone-testplan.outputs.branch-name || steps.get-milestone-development.outputs.branch-name || steps.get-milestone-prod.outputs.tagRefName }}
      branch-url: ${{ steps.get-milestone-testplan.outputs.branch-url || steps.get-milestone-development.outputs.branch-url || steps.get-milestone-prod.outputs.tagRefUrl }}
      failed-reason: ${{ steps.get-milestone-testplan.outputs.failedReason || steps.testplan-issue.outputs.failedReason || steps.testplan-issue2.outputs.failedReason || steps.request-form-testplan.outputs.failedReason || steps.testplan-request-eligible.outputs.failedReason || steps.prod-request-eligible.outputs.failedReason || steps.request-form-prod.outputs.failedReason || steps.get-milestone-prod.outputs.failedReason || steps.build-workflow-status.outputs.failedReason || steps.get-milestone-development.outputs.failedReason || steps.request-form-development.outputs.failedReason || steps.verify-deploy-version.outputs.failedReason || steps.validate-rollback.outputs.failedReason }}
      testplan-type: ${{ steps.testplan-issue.outputs.testplanType }}
      testplan-issue-number: ${{ steps.testplan-issue.outputs.testplanIssue-number }}
      testplan-issue-repo: ${{ steps.testplan-issue.outputs.testplanIssue-repo }}
      post-deployment-section: ${{ steps.request-form-prod.outputs.post_deployment_tasks_section }}
      use-existing-tag: ${{ steps.request-form-prod.outputs.use_existing_tag }}
      pr-number: ${{ steps.branch-pr.outputs.prNumber }}
      pr-url: ${{ steps.branch-pr.outputs.prUrl }}
      delete_schedule_time: ${{ steps.request-form-development.outputs.delete_schedule || steps.request-form-testplan.outputs.delete_schedule }}
    steps:
      - name: Display Needs
        env:
          RUN_ELIGIBLE_JSON: ${{ toJson(needs.run_eligible) }}
          UPDATE_REQ_JSON: ${{ toJson(needs.update_request) }}
        run: |
          echo "Needs of Validate Request: $RUN_ELIGIBLE_JSON"
          echo "Needs of Update Request: $UPDATE_REQ_JSON"
      - id: testplan-request-eligible
        if: needs.run_eligible.outputs.is-testplan == 'true'
        env:
          IS_TESTPLAN_PROVISION: ${{ needs.run_eligible.outputs.is-testplan-provision }}
          IS_TESTPLAN_DEPROVISION: ${{ needs.run_eligible.outputs.is-testplan-deprovision }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          # validation relaxed for milestone if deprovision
          if [[ "$IS_TESTPLAN_DEPROVISION" == "true" ]]; then
            ELIGIBLE="true"
          elif [[ "$IS_TESTPLAN_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, allow testplan deprovision request. found values, testplan deprovision? $IS_TESTPLAN_DEPROVISION"
            echo "Criteria-2, allow testplan provision only for open milestone. found values, milestone open? $IS_MILESTONE_OPEN, testplan provision? $IS_TESTPLAN_PROVISION"
            echo "failedReason=for testplan request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - id: prod-request-eligible
        if: needs.run_eligible.outputs.is-production == 'true'
        env:
          IS_PRODUCTION_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_PROD_ROLLBACK_PROVISION: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          if [[ "$IS_PRODUCTION_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$IS_PROD_ROLLBACK_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "false" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, allow production release provision request only for open milestone. found values, prod provision? $IS_PRODUCTION_PROVISION, milestone open? $IS_MILESTONE_OPEN"
            echo "Criteria-2, allow prod rollback only for closed milestone (indicates that already deployed). found values, prod rollback provision? $IS_PROD_ROLLBACK_PROVISION", milestone open? $IS_MILESTONE_OPEN"
            echo "failedReason=for prod request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: Checkout
        uses: actions/checkout@v4
      - id: get-milestone-development
        name: Validate Milestone and Branch
        if: needs.run_eligible.outputs.is-development == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const getEndOfDayCentral = (datetime) => {
                const date = new Date(datetime);
                if (isNaN(date.getTime())) {
                  return null; // Invalid Date
                }
                date.setHours(23);

                // Convert UTC to Central Time (America/Chicago) using timeZone offset
                const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                  timeZone: "America/Chicago",
                  year: "numeric",
                  month: "2-digit",
                  day: "2-digit",
                  hour: "2-digit",
                  minute: "2-digit",
                  second: "2-digit",
                  timeZoneName: "short"
                });

                // Format and extract adjusted time
                const centralTimeString = centralTimeFormat.format(date);
                const centralDate = new Date(centralTimeString);

                // Ensure time is set to 23:59:59 (end of the day)
                centralDate.setHours(23, 59, 59, 999);

                return centralDate;
              };
              // verify milestone branch exists
              console.log("issue has milestone title: ", context.payload.issue.milestone.title);
              // if milestone is open, there should be branch with milestone title
              const branchDetails = { name: "", url: "" };
              if(context.payload.issue.milestone.state === "open") {
                if(!context.payload.issue.milestone.due_on) {
                  throw new Error("Milestone due date is not set");
                }
                const milestoneDueOn = new Date(context.payload.issue.milestone.due_on);
                const endOfToday = getEndOfDayCentral(new Date());
                if(milestoneDueOn.toDateString() < endOfToday.toDateString()) {
                  throw new Error("Milestone due date is already passed");
                }
                const milestoneBranch = `milestone/${context.payload.issue.milestone.title}`;
                try {
                  const getBranchResponse = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: milestoneBranch
                  });
                  console.log("getBranchResponse: ", getBranchResponse);
                  branchDetails.name=getBranchResponse.data.name;
                  branchDetails.url=getBranchResponse.data._links.html;
                } catch(ignore) {
                 console.error("ignoring error:", ignore);
                }
              }
              if(!branchDetails.name) {
                // since there is no milestone branch, the master branch should have milestone version
                const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: "master"
                });
                branchDetails.name=getBranchResponse.data.name;
                branchDetails.url=getBranchResponse.data._links.html;
              }
              
              core.setOutput("branch-name", branchDetails.name); 
              core.setOutput("branch-url", branchDetails.url);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: get-milestone-testplan
        name: Validate Milestone and Branch
        # validation relaxed for milestone if deprovision
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        env:
          REQUEST_TYPE: ${{ needs.run_eligible.outputs.request-type }}
        with:
          script: |
            try {
              const getEndOfDayCentral = (datetime) => {
                const date = new Date(datetime);
                if (isNaN(date.getTime())) {
                  return null; // Invalid Date
                }
                date.setHours(23);

                // Convert UTC to Central Time (America/Chicago) using timeZone offset
                const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                  timeZone: "America/Chicago",
                  year: "numeric",
                  month: "2-digit",
                  day: "2-digit",
                  hour: "2-digit",
                  minute: "2-digit",
                  second: "2-digit",
                  timeZoneName: "short"
                });

                // Format and extract adjusted time
                const centralTimeString = centralTimeFormat.format(date);
                const centralDate = new Date(centralTimeString);

                // Ensure time is set to 23:59:59 (end of the day)
                centralDate.setHours(23, 59, 59, 999);

                return centralDate;
              };
              // verify milestone branch exists
              console.log("issue has milestone title: ", context.payload.issue.milestone.title);
              // if milestone is open, there should be branch with milestone title
              const branchDetails = { name: "", url: "" };
              if(context.payload.issue.milestone.state === "open") {
                if(!context.payload.issue.milestone.due_on) {
                  throw new Error("Milestone due date is not set");
                }
                const milestoneDueOn = new Date(context.payload.issue.milestone.due_on);
                const endOfToday = getEndOfDayCentral(new Date());
                if(milestoneDueOn.toDateString() < endOfToday.toDateString()) {
                  throw new Error("Milestone due date is already passed");
                }
                const milestoneBranch = `milestone/${context.payload.issue.milestone.title}`;
                try {
                  const getBranchResponse = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: milestoneBranch
                  });
                  console.log("getBranchResponse: ", getBranchResponse);
                  branchDetails.name=getBranchResponse.data.name;
                  branchDetails.url=getBranchResponse.data._links.html;
                } catch(e) {
                  // rethrow error and fail the step execution if provisioning request
                  if(process.env.REQUEST_TYPE === "provision") {
                    throw e;
                  }
                }
                // compare branch only if provisioning request
                if(process.env.REQUEST_TYPE === "provision") {
                  // verify milestone branch commit has merged all of the master branch
                  const compareResponse = await github.rest.repos.compareCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    base: "master",
                    head: milestoneBranch
                  });
                  console.log("milestone branch as head and master branch as base, compareResponse: ", compareResponse);
                  if (compareResponse.data.behind_by > 0) {
                    throw new Error(`Milestone branch [${milestoneBranch}] is behind master by ${compareResponse.data.behind_by} commits.`);
                  }
                }
              }
              if(context.payload.issue.milestone.state !== "open" || (process.env.REQUEST_TYPE === "deprovision" && !branchDetails.name)) {
                // if milestone is closed, the master branch should have milestone version
                // for deprovisioning, if milestone is open, the master branch should have milestone version;
                const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: "master"
                });
                branchDetails.name=getBranchResponse.data.name;
                branchDetails.url=getBranchResponse.data._links.html;
              }
              core.setOutput("branch", branchDetails); 
              core.setOutput("branch-name", branchDetails.name); 
              core.setOutput("branch-url", branchDetails.url);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: testplan-issue
        name: Validate Testplan issue
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        env:
          TESTPLAN_REQUEST_TYPE: ${{ needs.run_eligible.outputs.request-type }}
        with:
          script: |
            try {
              // verify if regression label exists ? if so, set as output for further use
              // currently only regression type testplan is allowed.
              const allowedTestplanTypes = ["regression"];
              const foundTypeLabel = context.payload.issue.labels.find(label=>allowedTestplanTypes.includes(label.name));
              core.setOutput("testplanType", foundTypeLabel?.name || "unknown");
              if(!foundTypeLabel) {
                throw new Error("Test plan type label not found in issue labels");
              }
              // find test plan issue with same milestone and type label
              const testplanIssueRegex = new RegExp(".+"+foundTypeLabel.name+" Test Plan:.+https://github.com/"+context.repo.owner+"/([^/]+)/issues/(\\d+).+", "i");
              if(!testplanIssueRegex.test(context.payload.issue.body)) {
                throw new Error("Test plan issue link not found")
              }
              const matchedGroups = testplanIssueRegex.exec(context.payload.issue.body);
              // console.log("found match groups: ", matchedGroups);
              const testplanIssueRepo = matchedGroups[1];
              const testplanIssueNumber = matchedGroups[2];
              if(!testplanIssueNumber || !testplanIssueRepo) {
                // this is unlikely, only in case of ambiguous request form 
                throw new Error("Test plan issue link is not properly formatted.");
              }
              const allowedLabels = [foundTypeLabel.name, "env: testplan"];
              if(testplanIssueRepo === context.repo.repo) {
                const getIssueResponse = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: testplanIssueRepo,
                  issue_number: testplanIssueNumber
                });
                console.log("getIssueResponse: ", getIssueResponse);
                const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
                if(testplanLabels.length!==allowedLabels.length){
                  throw new Error("missing required labels in given testplan issue");
                }
                if(getIssueResponse.data.milestone.number!==context.payload.issue.milestone.number){
                  throw new Error("assigned milestone to given testplan issue is not same with this issue");
                }
                // validation relaxed - testplan issue can be open or closed for deprovisioning
                if(process.env.TESTPLAN_REQUEST_TYPE === "provision" && getIssueResponse.data.state!=="open"){
                  throw new Error("testplan issue not open");
                }
              }
              const testplanDetails = {
                  number: testplanIssueNumber,
                  repo: testplanIssueRepo,
                  allowedLabels: allowedLabels
              };
              core.setOutput("testplanIssue", testplanDetails);
              core.setOutput("testplanIssue-number", testplanDetails.number);
              core.setOutput("testplanIssue-repo", testplanDetails.repo);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: testplan-issue2
        name: Validate testplan issue from another repo
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        env:
          TESTPLAN_REQUEST_TYPE: ${{ needs.run_eligible.outputs.request-type }}
        with:
          github-token: ${{ secrets.REPO_AWS_PAT }}
          script: |
            try {
              const testPlanIssueDetails = ${{ steps.testplan-issue.outputs.testplanIssue }};
              if(testPlanIssueDetails.repo === context.repo.repo) {
                console.log("already verified");
                return;
              }
              const getIssueResponse = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: testPlanIssueDetails.repo,
                issue_number: testPlanIssueDetails.number
              });
              console.log("getIssueResponse: ", getIssueResponse);
              const allowedLabels = testPlanIssueDetails.allowedLabels;
              const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
              if(testplanLabels.length!==allowedLabels.length){
                throw new Error("missing required labels in given testplan issue");
              }
              // validation relaxed - testplan issue can be open or closed for deprovisioning
              if(process.env.TESTPLAN_REQUEST_TYPE === "provision" && getIssueResponse.data.state!=="open"){
                throw new Error("testplan issue not open");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          cache: "pip" # caching pip dependencies
          python-version: "3.13"
      - id: request-issue
        uses: actions/github-script@v7
        with:
          script: |
            core.setOutput("issueDetails", context.payload.issue);
      - id: request-form-development
        if: needs.run_eligible.outputs.is-development == 'true'
        name: Validate Request form details
        env:
          REQUEST_TYPE: ${{ needs.run_eligible.outputs.request-type }}
          ISSUE_DETAILS: ${{ steps.request-issue.outputs.issueDetails }}
        run: |
          cd .github
          echo $ISSUE_DETAILS > request_form_issue_details.json
          python --version
          pip install -r scripts/requirements.txt
          # capture error code +-e
          set +e
          python -m scripts.request.deploy.development --validate \
              --request-form-issue-details "request_form_issue_details.json" \
              --request-type $REQUEST_TYPE > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - id: request-form-testplan
        if: needs.run_eligible.outputs.is-testplan == 'true'
        name: Validate Request form details
        env:
          TESTPLAN_TYPE: ${{ steps.testplan-issue.outputs.testplanType }}
          TESTPLAN_REQUEST_TYPE: ${{ steps.get-request-type.outputs.request-type }}
          ISSUE_DETAILS: ${{ steps.request-issue.outputs.issueDetails }}
          BRANCH_DETAILS: ${{ steps.get-milestone-testplan.outputs.branch }}
        run: |
          cd .github
          echo $ISSUE_DETAILS > request_form_issue_details.json
          echo $BRANCH_DETAILS > branch_details.json
          python --version
          pip install -r scripts/requirements.txt
          # capture error code +-e
          set +e
          python -m scripts.request.deploy.testplan --validate \
              --request-form-issue-details "request_form_issue_details.json" \
              --testplan-type "$TESTPLAN_TYPE" --request-type $TESTPLAN_REQUEST_TYPE \
              --branch-details "branch_details.json" > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - id: request-form-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Request Form Details
        env:
          ISSUE_DETAILS: ${{ steps.request-issue.outputs.issueDetails }}
        run: |
          cd .github
          echo $ISSUE_DETAILS > request_form_issue_details.json
          python --version
          pip install -r scripts/requirements.txt
          set +e
          python -m scripts.request.deploy.production --validate \
              --request-form-issue-details "request_form_issue_details.json"  > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - id: get-milestone-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Milestone and Branch
        uses: actions/github-script@v7
        env:
          IS_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          USE_EXISTING_TAG: ${{ steps.request-form-prod.outputs.use_existing_tag }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const getBranch = async (branchName, tagName) => {
                try {
                  if(branchName) {
                    const getBranchResponse = await github.rest.repos.getBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      branch: branchName
                    });
                    console.log("getBranchResponse: ", getBranchResponse);
                    return getBranchResponse.data;
                  }
                  if(tagName) {
                    const getRefResponse = await github.rest.git.getRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `tags/${tagName}`
                    });
                    console.log("getRefResponse: ", getRefResponse);
                    return getRefResponse.data;
                  }
                  throw new Error("requested neither branch nor tag");
                } catch(e) {
                  console.error("error during getBranch rest call", e);
                }
                return null;
              };
              // milestone due Date must be configured and is not past.
              if(!context.payload.issue.milestone.due_on) {
                throw new Error("Milestone due date is not set");
              }
              if(process.env.IS_ROLLBACK != "true") {
                // for prod deployment, date has to be today
                const milestoneDueOnDate = toTime(context.payload.issue.milestone.due_on).substring(0,10);
                if(milestoneDueOnDate !== toTime(new Date()).substring(0,10)) {
                  throw new Error("Milestone due date is not today");
                }
              }
              // verify milestone branch not exists
              const milestoneBranch = await getBranch(`milestone/${context.payload.issue.milestone.title}`);
              if(milestoneBranch) {
                throw new Error("milestone branch exist. It has to be merge to master and delete before prod deployment");
              }
              // verify tag ref
              const tagRef = await getBranch(null, context.payload.issue.milestone.title);
              if(tagRef && process.env.IS_ROLLBACK != "true" && process.env.USE_EXISTING_TAG != "true") {
                throw new Error(`for production deploy, tag [${context.payload.issue.milestone.title}] cannot exist.`);
              }
              if(!tagRef && process.env.IS_ROLLBACK == "true") {
                throw new Error(`for production rollback deploy, tag [${context.payload.issue.milestone.title}] not found.`);
              }
              if(tagRef?.ref) {
                core.setOutput("tagRefName", tagRef.ref);
                core.setOutput("tagRefUrl", `https://github.com/${context.repo.owner}/${context.repo.repo}/tree/${context.payload.issue.milestone.title}`);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: build-workflow-status
        name: Verify Latest Build Workflow Succeed
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.get-milestone-testplan.outputs.branch-name }}
          TAG_NAME: ${{ steps.get-milestone-prod.outputs.tagRefName }}
        with:
          script: |
            try {
              if(process.env.TAG_NAME) {
                console.log("tag exists for release/rollback. no need to verify workflow status");
                return;
              }
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const workflowName = "infra-build.yml";
              const branchName = process.env.BRANCH_NAME || "master";

              const listWorkflowRunsResponse = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowName,
                branch: branchName,
                event: "push",
                per_page: 1
              });
              console.log("listWorkflowRunsResponse=", listWorkflowRunsResponse);

              if (listWorkflowRunsResponse.data.workflow_runs.length === 0) {
                throw new Error(`No workflow runs found for branch [${branchName}].`);
              }

              const latestRun = listWorkflowRunsResponse.data.workflow_runs[0];
              console.log(`Latest run status: ${latestRun.status}, conclusion: ${latestRun.conclusion}`);

              if (latestRun.conclusion !== "success") {
                throw new Error(`Latest [Build workflow](${latestRun.html_url}) did not succeed. but found conclusion ${latestRun.conclusion} updated at ${toTime(latestRun.updated_at)}.");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during build workflow status validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: verify-deploy-version
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.get-milestone-testplan.outputs.branch-name }}
          TAG_NAME: ${{ steps.get-milestone-prod.outputs.tagRefName }}
        with:
          script: |
            try {
              if(process.env.TAG_NAME) {
                console.log("tag exists for release/rollback. no need to verify workflow status");
                return;
              }
              const branchName = process.env.BRANCH_NAME || "master";
              const getContentResponse = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: "package.json",
                ref: branchName
              });
              console.log("getContentResponse=", getContentResponse);
              // compare package.json and milestone version in master or milestone branch
              const packageJsonContent = Buffer.from(response.data.content, 'base64').toString();
              const packageJsonObj = JSON.parse(packageJsonContent);
              if(`v${packageJsonObj.version}` !== context.payload.issue.milestone.title) {
                throw new Error(`package.json version [${packageJsonObj.version}] in branch [${branchName}] does not match with requested release/milestone version [${context.payload.issue.milestone.title}]`);
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during verifying deploy version, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: validate-rollback
        name: Validate Rollback
        if: needs.run_eligible.outputs.is-prod-rollback == 'true'
        uses: actions/github-script@v7
        env:
          EXISTING_VERSION: ${{ steps.request-form-prod.outputs.existing_version }}
        with:
          script: |
            try {
              // tag is already verified
              // here, verify rollback milestone is closed
              // verify released approved issue exists
              // relaxed other validations
              const listMilestonesResponse = await github.rest.issues.listMilestones({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: "closed"
              });
              console.log("listMilestonesResponse: ", listMilestonesResponse);
              // here, verify rollback milestone is closed
              const deployedMilestone=listMilestonesResponse.data.find(mlst=>mlst.title===process.env.EXISTING_VERSION);
              if(!deployedMilestone) {
                throw new Error("deployed milestone is not found");
              }
              // verify approved prod release issue exists
              const listIssuesResponse = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ["deployment", "env: production"],
                state: "closed",
                milestone: deployedMilestone.number
              });
              console.log("listIssuesResponse: ", listIssuesResponse);
              const releasedRequest = listIssuesResponse.data.find(iss=>iss.title.startsWith("[Approved] [Request] Provision Production Environment"));
              if(!releasedRequest) {
                throw new Error("prod release request form not found");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during rollback validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: branch-pr
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.get-milestone-testplan.outputs.branch-name }}
        with:
          script: |
            try {
              if(!process.env.BRANCH_NAME.startsWith("milestone/")) {
                return;
              }
              const openPRListResponse = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: "master",
                head: process.env.BRANCH_NAME
              });
              console.log("openPRListResponse: ", openPRListResponse);
              const foundPr = openPRListResponse.data.find(pr=>pr.milestone.number===context.payload.issue.milestone.number)
              core.setOutput("prNumber", foundPr?.number);
              core.setOutput("prUrl", foundPr?.html_url);
            } catch(ignore) {
            }

  validate_request_stack:
    name: Validate Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
    outputs:
      failed-reason: ${{ steps.provision-stack-testplan.outputs.failedReason || steps.deprovision-stack-testplan.outputs.failedReason || steps.provision-stack-prod.outputs.failedReason || steps.provision-stack-prod-rollback.outputs.failedReason || steps.stack-development.outputs.failedReason }}
      stack-details: ${{ steps.provision-stack-testplan.outputs.stack_details || steps.deprovision-stack-testplan.outputs.stack_details || steps.provision-stack-prod.outputs.stack_details || steps.provision-stack-prod-rollback.outputs.stack_details || steps.stack-development.outputs.stack_details || '{}' }}
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: provision-stack-prod
        name: Verify branch is deployable
        # release or rollback
        if: needs.run_eligible.outputs.is-prod-provision == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ ! "$STACK_STATUS" =~ _COMPLETE$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is not complete, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "$STACK_AUDIT"
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: provision-stack-prod-rollback
        name: Verify Rollback Stack
        # release or rollback
        if: needs.run_eligible.outputs.is-prod-rollback == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
          ROLLBACK_MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Infra Stack does not exist. Rollback is not possible"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit $RET_CODE
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is in progress, $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check milestone 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" == "$ROLLBACK_MILESTONE_TITLE" ]]; then
            FAILED_REASON="There was already rollback deployment attempt. Another attempt is not possible"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "$STACK_AUDIT"
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: provision-stack-testplan
        name: Verify branch is deployable
        if: needs.run_eligible.outputs.is-testplan-provision == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISS_REPO: ${{ needs.validate_request.outputs.testplan-issue-repo }}
          TESTPLAN_ISS_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          # replacing status check. previously was _COMPLETE, but if status is failed, allow to redeploy
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is in progress, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check milestone 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Type 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanType").Value')
          if [[ "$TAG_VALUE" != "$TESTPLAN_TYPE" ]]; then
            FAILED_REASON="The testplan type doesnot match. Found $TAG_VALUE testplan type."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Issue number 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanIssueNumber").Value')
          EXPECTED_TESTPLAN_ISS="$TESTPLAN_ISS_REPO/issue-$TESTPLAN_ISS_NUMBER"
          if [[ "$TAG_VALUE" != "$EXPECTED_TESTPLAN_ISS" ]]; then
            FAILED_REASON="The stack is deployed for another testplan issue, $TAG_VALUE, instead of $EXPECTED_TESTPLAN_ISS."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: deprovision-stack-testplan
        if: needs.run_eligible.outputs.is-testplan-deprovision == 'true'
        name: Verify branch is destroyable
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"  
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Infra Stack does not exist. given branch for milestone has already been destroyed."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanType").Value')
          if [[ "$TAG_VALUE" != "$TESTPLAN_TYPE" ]]; then
            FAILED_REASON="The testplan type is not matching with deployed stack. The stack is deployed for $TAG_VALUE testplan type, but expected $TESTPLAN_TYPE."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: stack-development
        if: needs.run_eligible.outputs.is-development == 'true'
        name: Verify stack deployable or destroyable
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          IS_PROVISION_REQ: ${{ needs.run_eligible.outputs.is-development-provision }}
          IS_DEPROVISION_REQ: ${{ needs.run_eligible.outputs.is-development-deprovision }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"  
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 && "$IS_PROVISION_REQ" == "true" ]]; then
            echo "Infra Stack does not exist. given branch can be deployed."
            exit 0
          fi

          if [[ $RET_CODE -ne 0 && "$IS_DEPROVISION_REQ" == "true" ]]; then
            FAILED_REASON="Infra Stack does not exist. it has already been destroyed."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  verify_branch_tag:
    name: Verify Branch or Tag
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_request_stack
    outputs:
      failed-reason: ${{ steps.no-branch.outputs.failedReason || steps.create-prod-tag.outputs.failedReason }}
      branch-tag-name: ${{ needs.validate_request.outputs.branch-name || github.event.issue.milestone.title }}
    if: needs.run_eligible.outputs.request-type == 'provision'
    steps:
      - id: no-branch
        env:
          BRANCH_NAME: ${{ needs.validate_request.outputs.branch-name }}
          IS_PROD_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_PROD_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
          IS_DEVELOPMENT: ${{ needs.run_eligible.outputs.is-development }}
          USE_EXISTING_TAG: ${{ needs.validate_request.outputs.use-existing-tag }}
        run: |
          if [[ -z "$BRANCH_NAME" ]]; then
            if [[ "$IS_PROD_ROLLBACK" == "true" ]]; then
              FAILED_REASON="Tag for prod rollback is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
            if [[ "$IS_TESTPLAN" == "true" ]]; then
              FAILED_REASON="Milestone or master Branch is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
            if [[ "$IS_DEVELOPMENT" == "true" ]]; then
              FAILED_REASON="Milestone or master Branch is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
          elif [[ "$IS_PROD_PROVISION" == "true" && "$USE_EXISTING_TAG" != "true" ]]; then
            FAILED_REASON="Tag cannot be available for prod."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "$FAILED_REASON"
            exit 1
          fi
          CREATE_TAG="false"
          if [[ "$IS_PROD_PROVISION" == "true" ]]; then
            if [[ -z "$BRANCH_NAME" ]]; then
              CREATE_TAG="true"
            fi
          fi
          echo "create_tag=$CREATE_TAG" >> $GITHUB_OUTPUT
          echo "create_tag=$CREATE_TAG"
      - name: Checkout
        uses: actions/checkout@v4
      - id: create-prod-tag
        name: Create Tag
        if: steps.no-branch.outputs.create_tag == 'true'
        env:
          TAG_VER: ${{ github.event.issue.milestone.title }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          LOG_FILE="create_tag.failed.log"
          if ! git tag -a "$TAG_VER" -m "Release $TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to create tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi
          if ! git push origin "$TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to push tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi

  diff:
    name: Infra Stack Diff
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_request_stack
      - verify_branch_tag
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      stack-tags: ${{ steps.prepare-tags.outputs.stackTags }}
    steps:
      - name: Display Needs
        env:
          VALIDATE_REQ_JSON: ${{ toJson(needs.validate_request) }}
        run: |
          echo "Needs of Validate Request: $VALIDATE_REQ_JSON"
          echo "Milestone branch name: ${{ needs.validate_request.outputs.branch-name }}"
          echo "Testplan Type: ${{ needs.validate_request.outputs.testplan-type }}"
          echo "Testplan Issue Number: ${{ needs.validate_request.outputs.testplan-issue-number }}"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.verify_branch_tag.outputs.branch-tag-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          pwd
          mkdir -p dist/ui
          echo ls -lrt
          ls -lrt
          echo ls -lrt dist
          ls -lrt dist
          echo ls -lrt ../
          ls -lrt ../
      - id: prepare-tags
        uses: actions/github-script@v7
        env:
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISSUE_REPO: ${{ needs.validate_request.outputs.testplan-issue-repo }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
        with:
          script: |
            const stackTags = [];
            stackTags.push(`workflow_run_id=${context.runId}`);
            stackTags.push(`milestone=${context.payload.issue.milestone.title}`);
            if(process.env.TESTPLAN_TYPE && process.env.TESTPLAN_ISSUE_REPO && process.env.TESTPLAN_ISSUE_NUMBER) {
              stackTags.push(`testplanType=${process.env.TESTPLAN_TYPE}`);
              stackTags.push(`testplanIssueNumber=${process.env.TESTPLAN_ISSUE_REPO}/issue-${process.env.TESTPLAN_ISSUE_NUMBER}`);
            }
            stackTags.push(`requestIssueNumber=${context.repo.repo}/issue-${context.payload.issue.number}`);
            core.setOutput("stackTags", stackTags);
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: cdk diff
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "diff"
          actions_comment: false
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ join(steps.prepare-tags.outputs.stackTags) }}
          DELETE_SCHEDULE_TIME: ${{ needs.validate_request.outputs.delete_schedule_time }}

  deployment:
    name: Deploy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - diff
      - verify_branch_tag
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.deploying-comment.outputs.failedReason || steps.describe-stack.outputs.failedReason || steps.update-issue-deploy-complete.outputs.failedReason || steps.post-deployment-verification-issue.outputs.failedReason }}
    steps:
      - name: Display Needs
        env:
          VALIDATE_REQ_JSON: ${{ toJson(needs.validate_request) }}
          UPDATE_REQ_JSON: ${{ toJson(needs.update_request) }}
          DIFF_JSON: ${{ toJson(needs.diff) }}
          STACK_REQ_JSON: ${{ toJson(needs.validate_request_stack) }}
        run: |
          echo "Needs of Validate Request: $VALIDATE_REQ_JSON"
          echo "Needs of Update Request: $UPDATE_REQ_JSON"
          echo "Needs of Diff: $DIFF_JSON"
          echo "Needs of Validate Request Stack: $STACK_REQ_JSON"
          echo "from update request, Original Issue Title: ${{ needs.run_eligible.outputs.original-issue-title }}"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.verify_branch_tag.outputs.branch-tag-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm --version
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          cd dist/lambda_layer/nodejs
          npm install .
          cd ../../..
          mkdir -p dist/ui
          pwd
          echo ls -lrt
          ls -lrt
          echo ls -lrt dist
          ls -lrt dist
          echo ls -lrt dist/ui
          ls -lrt dist/ui
          echo ls -lrt ../
          ls -lrt ../
      - id: deploying-comment
        name: Update Issue - Deploying
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.verify_branch_tag.outputs.branch-tag-name }}
          IS_FOR_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
          IS_FOR_DEVELOPMENT: ${{ needs.run_eligible.outputs.is-development }}
          IS_PROD_RELEASE: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_PROD_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
          PR_LINK: ${{ needs.validate_request.outputs.pr-url }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const deploymentStartTime = new Date().toISOString();
              core.setOutput("deploymentStartTime", deploymentStartTime);
              let prodType="";
              if(process.env.IS_PROD_RELEASE == "true") {
                prodType="Release "
              }
              if(process.env.IS_PROD_ROLLBACK == "true") {
                prodType="Rollback "
              }
              const commentBody = [
                `## Infra ${prodType}Deployment Started`,
                "", "### Start Time: ", "",
                "  " + toTime(deploymentStartTime)
              ];
              if("true" == process.env.IS_FOR_TESTPLAN || "true" == process.env.IS_FOR_DEVELOPMENT) {
                commentBody.push("", "### Branch: ", "");
              } else {
                commentBody.push("", "### Tag: ", "");
              }
              commentBody.push("  " + process.env.MILESTONE_BRANCH_NAME);

              const stackDetails = ${{ needs.validate_request_stack.outputs.stack-details }};
              commentBody.push("", "### API Stack: ", "");
              
              if(stackDetails.api) {
                // audit details available
                commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
                commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              } else {
                commentBody.push("API Stack is not found. It seems to be first deployment.");
              }
              if(process.env.PR_NUMBER && process.env.PR_LINK) {
                commentBody.push("", "### Open PR" ,"");
                commentBody.push(`- [PR - ${process.env.PR_NUMBER}](${process.env.PR_LINK})`);
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the deployment to complete. This issue will be updated with deployment status.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              // console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment start comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: cdk-deploy
        name: cdk deploy
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "deploy"
          cdk_stack: "MyFinanceInfraStack"
          debug_log: true
          actions_comment: false
          cdk_args: "--require-approval never --exclusively"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ needs.diff.outputs.stack-tags }}
          DELETE_SCHEDULE_TIME: ${{ needs.validate_request.outputs.delete_schedule_time }}
        continue-on-error: true
      - id: describe-stack
        name: Describe stack
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          CDK_DEPLOY_OUTCOME: ${{ steps.cdk-deploy.outcome }}
        run: |
          echo "cdk deploy outcome: $CDK_DEPLOY_OUTCOME"
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Failed to describe stack. Error: $DESCRIBE_STACK_OUT"
            echo "failedReason=$FAILED_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            exit $RET_CODE
          fi
          if [ "$CDK_DEPLOY_OUTCOME" == "failure" ]; then
            STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="CDK deployment failed. please check logs for details. Stack Status is $STACK_STATUS and Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          STACK_OUTPUTS=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Outputs")
          STACK_TAGS=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags")
          STACK_AUDIT='{"api":'$API_STACK_AUDIT',"outputs":'$STACK_OUTPUTS',"tags":'$STACK_TAGS'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: post-deployment-verification-issue
        name: Post Deployment Verification Issue
        uses: actions/github-script@v7
        if: needs.run_eligible.outputs.is-production == 'true'
        env:
          POST_DEPLOY_REQ_SECTION: ${{ needs.validate_request.outputs.post-deployment-section }}
          IS_RELEASE: ${{ needs.run_eligible.outputs.is-prod-provision }}
        with:
          script: |
            try {
              let deploymentType = "Release";
              if(process.env.IS_RELEASE != "true") {
                deploymentType = "Rollback";
              }
              let issueBody = `\n## ${deploymentType} Deployment Completed\n\n`;
              issueBody += `- Parent Request [Issue-${context.payload.issue.number}](${context.payload.issue.html_url})\n\n`;
              issueBody += process.env.POST_DEPLOY_REQ_SECTION;
              issueBody += "\n\n  ";
              issueBody += "> [!IMPORTANT]  \n";
              issueBody += "> Please checked tasks if verified successfully. When post deployment verification is completed, close the issue regardless the status to mark the deployment attempt complete.  ";
              const createIssueResponse = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: "[Task] Post Deployment Verifications for Prod " + deploymentType,
                body: issueBody,
                labels: context.payload.issue.labels.map(label=>label.name),
                milestone: context.payload.issue.milestone.number
              });
              console.log("api createIssueResponse: ", createIssueResponse);
              core.setOutput("issueNumber", createIssueResponse.data.number);
              
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: createIssueResponse.data.number
              });
              console.log("lock issue response:", lockIssueResponse);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update for deployment completion, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: update-issue-deploy-complete
        name: Update Issue - Deployment Complete
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_START_TIME: ${{ steps.deploying-comment.outputs.deploymentStartTime }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
          POST_VERFCT_ISSUE_NUM: ${{ steps.post-deployment-verification-issue.outputs.issueNumber }}
        with:
          script: |
            try {
              console.log("Deployment Start Time: ", process.env.DEPLOYMENT_START_TIME);
              const stackDetails = ${{ steps.describe-stack.outputs.stack_details }};
              console.log("Stack Details: ", stackDetails);
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const deploymentEndTime = new Date();
              const diffParts = new Date(deploymentEndTime - new Date(process.env.DEPLOYMENT_START_TIME)).toISOString().substr(11, 8).split(":");
              const getNonZero = (value, suffix) => {
                const pluralS = value>1? "s" : "";
                if(value>0) { 
                  return `${value} ${suffix}${pluralS}`; 
                }
                return "";
              };
              let duration = "";
              duration += getNonZero(parseInt(diffParts[0]), "hour") + " ";
              duration += getNonZero(parseInt(diffParts[1]), "minute") + " ";
              duration += getNonZero(parseInt(diffParts[2]), "second") + " ";
              
              const commentBody = [
                "## Infra Deployment Completed",
                "<br/>", 
                "", "### Deployment Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${toTime(process.env.DEPLOYMENT_START_TIME)} |`,
                `| **End Time** | ${toTime(deploymentEndTime.toISOString())} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];
              
              commentBody.push("", "### Stack Outputs: ", "");
              stackDetails.outputs.forEach(output => {
                if(output.OutputKey.startsWith("DistributionDomain")) {
                  commentBody.push(` - **${output.OutputKey}:** https://${output.OutputValue}  `);
                } else {
                  commentBody.push(` - **${output.OutputKey}:** ${output.OutputValue}  `);
                }
              });
              if(stackDetails.outputs.length === 0) {
                commentBody.push("  No outputs found.  ");
              }
              
              commentBody.push("", "### Stack Tags: ", "");
              stackDetails.tags.forEach(tag => {
                commentBody.push(` - **${tag.Key}:** ${tag.Value}  `);
              });

              commentBody.push("", "### Stack Audit: ", "");
              // audit details available
              commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
              commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              
              if(process.env.POST_VERFCT_ISSUE_NUM) {
                commentBody.push("", "### Post Verification Issue Created");
                commentBody.push("#"+process.env.POST_VERFCT_ISSUE_NUM);
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The deployment is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              // console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
              if(process.env.PR_NUMBER) {
                const prCommentResponse = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: commentBody.join("\n")
                });
                console.log("for PR, commentResponse: ", prCommentResponse);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment complete comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  destroy:
    name: Destroy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_request_stack
    if: needs.run_eligible.outputs.is-testplan-deprovision == 'true'
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.destroying-comment.outputs.failedReason || steps.describe-stack.outputs.failedReason || steps.update-issue-destroy-complete.outputs.failedReason || steps.empty-bucket.outputs.failedReason }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_request.outputs.branch-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm --version
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          mkdir -p dist/ui
          pwd
      - id: destroying-comment
        name: Update Issue - Deploying
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.validate_request.outputs.branch-name }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
          PR_LINK: ${{ needs.validate_request.outputs.pr-url }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const destroyStartTime = new Date().toISOString();
              core.setOutput("destroyStartTime", destroyStartTime);
              const commentBody = [
                "## Infra Stack Destroy Started",
                "", "### Start Time: ", "",
                "  " + toTime(destroyStartTime)
              ];
              if(process.env.MILESTONE_BRANCH_NAME.startsWith("milestone/")) {
                commentBody.push("", "### Milestone Branch: ", "");
                commentBody.push("  " + process.env.MILESTONE_BRANCH_NAME);
              }

              const stackDetails = ${{ needs.validate_request_stack.outputs.stack-details }};
              commentBody.push("", "### API Stack: ", "");
              // audit details available
              commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
              commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));

              if(process.env.PR_NUMBER && process.env.PR_LINK) {
                commentBody.push("", "### Open PR" ,"");
                commentBody.push(`- [PR - ${process.env.PR_NUMBER}](${process.env.PR_LINK})`);
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the destroy to complete. This issue will be updated with destroy status.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during destroy start comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: empty-bucket
        name: Empty S3 bucket
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
        run: |
          RECEIPT_S3_BUCKET="prsfin-$INFRA_ENV-expense-receipt-s3-bucket"
          echo "deleting all objects from s3 bucket [$RECEIPT_S3_BUCKET] before destroying stack"
          set +e
          EMPTY_BUCKET_OUT=$(aws s3 rm s3://$RECEIPT_S3_BUCKET --recursive --only-show-errors)
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 || -n $EMPTY_BUCKET_OUT ]]; then
            FAILED_REASON="There was error emptying bucket. Error: $EMPTY_BUCKET_OUT"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "failedReason=$FAILED_REASON"
            exit 1
          fi
      - id: prepare-stack-tags
        env:
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
        run: |
          echo "stack_tags=milestone=$MILESTONE_TITLE" >> $GITHUB_OUTPUT
      - name: cdk destroy
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "destroy"
          debug_log: true
          actions_comment: false
          cdk_args: "--force"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ steps.prepare-stack-tags.outputs.stack_tags }}
        continue-on-error: true
      - id: describe-stack
        name: Describe stack
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
        run: |
          STACK_NAME="prsfin-$INFRA_ENV-ui-deploy-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -eq 0 ]]; then
            STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            echo "failedReason=UI Stack has not be destroyed. Stack Staus: $STACK_STATUS. and reason: $STACK_STATUS_REASON" >> $GITHUB_OUTPUT
            exit 1
          fi

          STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -eq 0 ]]; then
            STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            echo "failedReason=Infra Stack has not be destroyed. Stack Staus: $STACK_STATUS. and reason: $STACK_STATUS_REASON" >> $GITHUB_OUTPUT
            exit 1
          fi
      - id: update-issue-destroy-complete
        name: Update Issue - Destroy Complete
        uses: actions/github-script@v7
        env:
          DESTROY_START_TIME: ${{ steps.destroying-comment.outputs.destroyStartTime }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
        with:
          script: |
            try {
              const destroyEndTime = new Date();
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const diffParts = new Date(destroyEndTime - new Date(process.env.DESTROY_START_TIME)).toISOString().substr(11, 8).split(":");
              const getNonZero = (value, suffix) => {
                const pluralS = value>1? "s" : "";
                if(value>0) { 
                  return `${value} ${suffix}${pluralS}`; 
                }
                return "";
              };
              let duration = "";
              duration += getNonZero(parseInt(diffParts[0]), "hour") + " ";
              duration += getNonZero(parseInt(diffParts[1]), "minute") + " ";
              duration += getNonZero(parseInt(diffParts[2]), "second") + " ";
              const commentBody = [
                "## Stack Destroy Completed",
                "<br/>", 
                "", "### Destroy Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${toTime(process.env.DESTROY_START_TIME)} |`,
                `| **End Time** | ${toTime(destroyEndTime)} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The Destroy is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");
              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              
              const commentResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
              if(process.env.PR_NUMBER) {
                const prCommentResponse = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: commentBody.join("\n")
                });
                console.log("for PR, commentResponse: ", prCommentResponse);
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update for destroy completion, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  handle_failure:
    name: Handle Request form Failure
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - verify_branch_tag
      - diff
      - deployment
      - destroy
    if: failure()
    steps:
      - run: |
          echo 'Run Eligible: ${{ needs.run_eligible }}'
          echo 'Update Request: ${{ needs.update_request }}'
          echo 'Validate Request: ${{ needs.validate_request }}'
          echo 'Validate Request Stack: ${{ needs.validate_request_stack }}'
          echo 'Create Tag: ${{ needs.verify_branch_tag }}'
          echo 'Diff: ${{ needs.diff }}'
          echo 'Deployment: ${{ needs.deployment }}'
          echo 'Destroy: ${{ needs.destroy }}'
      - if: needs.run_eligible.result == 'failure'
        run: |
          echo "Since run eligible job failed, skipping fail handler job"
          exit 1
      - id: prepare-error
        uses: actions/github-script@v7
        env:
          VALIDATION_FAIL_REASON: ${{ needs.update_request.outputs.failed-reason || needs.validate_request.outputs.failed-reason || needs.validate_request_stack.outputs.failed-reason }}
          IS_VALIDATION_FAILED: ${{ needs.update_request.result == 'failure' || needs.validate_request.result == 'failure' || needs.validate_request_stack.result == 'failure' || needs.diff.result == 'failure' }}
          DEPLOY_FAILED_REASON: ${{ needs.verify_branch_tag.outputs.failed-reason || needs.deployment.outputs.failed-reason }}
          IS_DEPLOY_FAILED: ${{ needs.deployment.result == 'failure' || needs.verify_branch_tag.result == 'failure' }}
          DESTROY_FAILED_REASON: ${{ needs.destroy.outputs.failed-reason }}
          IS_DESTROY_FAILED: ${{ needs.destroy.result == 'failure' }}
        with:
          script: |
            let errorDetails= "Found unknown error. Please check the logs.";
            if(String(process.env.IS_VALIDATION_FAILED) === "true") {
              errorDetails = process.env.VALIDATION_FAIL_REASON || errorDetails;
              core.setOutput("reason", "Validation of Api Request form is failed.");
              core.setOutput("status", "Denied");
            } else if(String(process.env.IS_DEPLOY_FAILED) === "true") {
              errorDetails = process.env.DEPLOY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Deployment of Infra stack is failed.");
              core.setOutput("status", "Failed");
            } else if(String(process.env.IS_DESTROY_FAILED) === "true") {
              errorDetails = process.env.DESTROY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Destroy of Infra Stack is failed.");
              core.setOutput("status", "Failed");
            } else {
              throw new Error("could not find any fail job");
            }
            core.setOutput("details", errorDetails);
      - name: Add Failed Reason as Comment
        uses: actions/github-script@v7
        env:
          FAIL_REASON: ${{ steps.prepare-error.outputs.reason }}
          ERROR_DETAILS: ${{ steps.prepare-error.outputs.details }}
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
        with:
          script: |
            const commentBody = [
                    "## Request " + process.env.FAIL_STATUS, 
                    "", "### Reason:", "",
                    "  " + process.env.FAIL_REASON, "",
                    "**Error:**  " + process.env.ERROR_DETAILS, 
                    "<br/>",  "",
                    "> [!NOTE]",
                    "> **Needs Action:**   Please raise a `new request form` with correct details. This request issue will be `closed`.",
                    "<br/>", "<br/>",  "",
                  ];
            const workflowTitle = context.workflow +" (" + context.runId + ")";
            const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
            commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

            console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
            const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
            });
            console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
            const commentResponse = github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody.join("\n")
            });
            console.log("commentResponse: ", commentResponse);
      - name: Close Issue
        uses: actions/github-script@v7
        env:
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            const closeUpdateResponse = await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              state: 'closed',
              title: "[" + process.env.FAIL_STATUS + "]" + process.env.ORIGINAL_ISSUE_TITLE,
            });
            console.log("closeUpdateResponse: ", closeUpdateResponse);
            const lockIssueResponse = await github.rest.issues.lock({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number
            });
            console.log("issue is lock again, lock issue response:", lockIssueResponse);
