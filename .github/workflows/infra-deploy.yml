# This workflow performs basic steps
# build, compile, synth and unit test
name: AWS Infra Deploy

on:
  issues:
    types:
      - opened

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.milestone.number }}-${{ toJson(github.event.issue.labels.*.name) }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read
  issues: write

jobs:
  display_output:
    name: Display Output
    runs-on: ubuntu-latest
    steps:
      # https://docs.github.com/en/webhooks/webhook-events-and-payloads#issues
      - run: |
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue id: ${{ github.event.issue.id }}"
      - run: |
          echo "Issue title: ${{ github.event.issue.title }}"
      - run: |
          echo "Issue body: ${{ github.event.issue.body }}"
      - run: |
          echo "Issue milestone title: ${{ github.event.issue.milestone.title }}"
          echo "Issue milestone: ${{ toJson(github.event.issue.milestone) }}"
      - run: |
          echo "Issue state: ${{ github.event.issue.state }}"
          echo "Issue state reason: ${{ github.event.issue.state_reason }}"
      - run: |
          echo "Issue draft: ${{ github.event.issue.draft }}"
          echo "Issue locked: ${{ github.event.issue.locked }}"
          echo "Issue active lock reason: ${{ github.event.issue.active_lock_reason }}"
      - run: |
          echo "Issue labels name: ${{ toJson(github.event.issue.labels.*.name) }}"
      - run: |
          echo "Issue total comments: ${{ github.event.issue.comments }}"
      - run: |
          echo "Issue updated at: ${{ github.event.issue.updated_at }}"
          echo "Issue closed at: ${{ github.event.issue.closed_at }}"
          echo "Issue created at: ${{ github.event.issue.created_at }}"
      - run: |
          echo "Issue author association: ${{ github.event.issue.author_association }}"
      - run: |
          echo "Issue sender login: ${{ github.event.sender.login }}"
          echo "Issue sender type: ${{ github.event.sender.type }}"
          echo "Issue sender id: ${{ github.event.sender.id }}"
          echo "Issue sender view type: ${{ github.event.sender.user_view_type }}"
      - run: |
          echo "Issue user login: ${{ github.event.issue.user.login }}"
          echo "Issue user type: ${{ github.event.issue.user.type }}"
          echo "Issue user id: ${{ github.event.issue.user.id }}"
          echo "Issue user view type: ${{ github.event.issue.user.user_view_type }}"
      - run: |
          echo "Issue assignee login: ${{ github.event.issue.assignee.login }}"
          echo "Issue assignee type: ${{ github.event.issue.assignee.type }}"
          echo "Issue assignee id: ${{ github.event.issue.assignee.id }}"
          echo "Issue assignee view type: ${{ github.event.issue.assignee.user_view_type }}"
      - run: |
          echo "github actor: ${{ github.actor }}"
          echo "github triggering actor: ${{ github.triggering_actor }}"
          echo "Issue perfomed by app: ${{ github.event.issue.performed_via_github_app }}"
      - run: |
          echo "action: ${{ github.action }}"
          echo "event name: ${{ github.event_name }}"
          echo "event changes: ${{ github.event.changes }}"
          echo "event action: ${{ github.event.action }}"
      - run: |
          echo 'github json: ${{ toJson(github) }}'
      - uses: actions/github-script@v7
        with:
          script: |
            console.log("Context obj: ", context);
            console.log("Github config: ", github)
            console.log("Github Rest API config: ", github.rest)
            console.log("Github Rest Issues API:", github.rest.issues)

  run_eligible:
    name: Workflow Run Eligible
    runs-on: ubuntu-latest
    outputs:
      original-issue-title: ${{ github.event.issue.title }}
      is-prod-provision: ${{ steps.request-form-issue.outputs.is-prod-provision }}
      is-testplan-provision: ${{ steps.request-form-issue.outputs.is-testplan-provision }}
      is-testplan-deprovision: ${{ steps.request-form-issue.outputs.is-testplan-deprovision }}
      is-prod-rollback: ${{ steps.request-form-issue.outputs.is-prod-rollback }}
      is-testplan: ${{ steps.request-form-issue.outputs.for-testplan }}
      is-production: ${{ steps.request-form-issue.outputs.for-production }}
      env-ref-name: ${{ steps.request-form-issue.outputs.env-ref-name }}
    steps:
      - run: |
          echo "Eligibilities"
          echo "Request form is for deployment purpose"
          echo "Request form must assigned milestone"
          echo "Request form is created by owner"
          echo "Only 1 Environment must exist"
          echo "Request form is either provision or deprovision request"
      - if: >
          ! contains(github.event.issue.labels.*.name, 'deployment') ||
          ! startsWith(github.event.issue.author_association, 'OWNER') ||
          ! github.event.issue.milestone != null
        run: |
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          ! contains(github.event.issue.labels.*.name, 'production') && 
          ! contains(github.event.issue.labels.*.name, 'test plan')
        run: |
          echo "environment label is not defined to issue"
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          contains(github.event.issue.labels.*.name, 'production') && 
          contains(github.event.issue.labels.*.name, 'test plan')
        run: |
          echo "both environment labels are defined to issue"
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          ! startsWith(github.event.issue.title, '[Request] Provision ') && 
          ! startsWith(github.event.issue.title, '[Request] [Rollback] Provision ') && 
          ! startsWith(github.event.issue.title, '[Request] Deprovision ')
        run: |
          echo "It is not Request form for provision or deprovision"
          echo Workflow is not eligible to process issue
          exit 1
      - id: request-form-issue
        name: Request Form Issue categorized
        env:
          IS_TESTPLAN: ${{ contains(github.event.issue.labels.*.name, 'test plan') }}
          IS_TESTPLAN_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] Provision Test Plan Environment') }}
          IS_TESTPLAN_DEPROVISION: ${{ startsWith(github.event.issue.title, '[Request] Deprovision Test Plan Environment') }}
          IS_PRODUCTION: ${{ contains(github.event.issue.labels.*.name, 'production') }}
          IS_PRODUCTION_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] Provision Production Environment') }}
          IS_PROD_ROLLBACK_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] [Rollback] Provision Production Environment') }}
        run: |
          if [[ "$IS_TESTPLAN" == "true" ]]; then
            echo "env-ref-name=testplan" >> $GITHUB_OUTPUT
          fi
          if [[ "$IS_PRODUCTION" == "true" ]]; then
            echo "env-ref-name=production" >> $GITHUB_OUTPUT
          fi
          echo "for-testplan=$IS_TESTPLAN" >> $GITHUB_OUTPUT
          echo "for-production=$IS_PRODUCTION" >> $GITHUB_OUTPUT
          echo "is-testplan-provision=$IS_TESTPLAN_PROVISION" >> $GITHUB_OUTPUT
          echo "is-testplan-deprovision=$IS_TESTPLAN_DEPROVISION" >> $GITHUB_OUTPUT
          echo "is-prod-provision=$IS_PRODUCTION_PROVISION" >> $GITHUB_OUTPUT
          echo "is-prod-rollback=$IS_PROD_ROLLBACK_PROVISION" >> $GITHUB_OUTPUT

  update_request:
    name: Start Request
    runs-on: ubuntu-latest
    needs:
      - run_eligible
    outputs:
      failed-reason: ${{ steps.update-request.outputs.failedReason }}
    steps:
      - run: |
          echo "The issue has milestone assigned and locked."
          echo "The issue has required labels (deployment, test plan)."
          echo "This request form is raised by owner."
          echo "This request form title indicates that It is related to provision or deprovision test plan environment."
          echo "We will validate request form issue details."
      - id: update-request
        name: Update Issue - Start Processing
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const updateResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Processing] " + context.payload.issue.title
              });
              console.log("updateResponse: ", updateResponse);
              if(!context.payload.issue.locked) {
                const lockIssueResponse = await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number
                });
                console.log("Lock issue response:", lockIssueResponse);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  validate_request:
    name: Validate Request Form
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
    outputs:
      branch-name: ${{ steps.get-milestone-testplan.outputs.branch-name || steps.get-milestone-prod.outputs.tagRefName }}
      branch-url: ${{ steps.get-milestone-testplan.outputs.branch-url || steps.get-milestone-prod.outputs.tagRefUrl }}
      failed-reason: ${{ steps.get-milestone-testplan.outputs.failedReason || steps.testplan-issue.outputs.failedReason || steps.testplan-issue2.outputs.failedReason || steps.request-form-testplan.outputs.failedReason || steps.testplan-request-eligible.outputs.failedReason || steps.prod-request-eligible.outputs.failedReason || steps.request-form-prod.outputs.failedReason || steps.get-milestone-prod.outputs.failedReason }}
      testplan-type: ${{ steps.testplan-issue.outputs.testplanType }}
      request-type: ${{ steps.get-request-type.outputs.request-type }}
      testplan-issue-number: ${{ steps.testplan-issue.outputs.testplanIssue-number }}
      testplan-issue-repo: ${{ steps.testplan-issue.outputs.testplanIssue-repo }}
    steps:
      - run: |
          echo "if provision, allowed environment is either testplan or production"
          echo "if deprovision, allowed environment is testplan"
          echo "rollback is only for production environment"
          echo "if provision, milestone must be open except case of rollback"
          echo "if production, tag and milestone branch must not exist"
          echo "if rollback, milestone must be closed."
          echo "if rollback, milestone must be immediate good previous version"
          echo "if rollback, tag must exist"
      - id: testplan-request-eligible
        if: needs.run_eligible.outputs.is-testplan == 'true'
        env:
          IS_TESTPLAN_PROVISION: ${{ needs.run_eligible.outputs.is-testplan-provision }}
          IS_TESTPLAN_DEPROVISION: ${{ needs.run_eligible.outputs.is-testplan-deprovision }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          if [[ "$IS_TESTPLAN_PROVISION" == "true" || "$IS_TESTPLAN_DEPROVISION" == "true" ]]; then
            if [[ "$IS_MILESTONE_OPEN" == "true" ]]; then
              ELIGIBLE="true"
            fi
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, testplan provision or deprovision request. But found values, testpln provision? $IS_TESTPLAN_PROVISION, testplan deprovision? $IS_TESTPLAN_DEPROVISION"
            echo "Criteria-2, testplan environment."
            echo "Criteria-3, open milestone. But found values, milestone open? $IS_MILESTONE_OPEN"
            echo "failedReason=for testplan request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: prod-request-eligible
        if: needs.run_eligible.outputs.is-production == 'true'
        env:
          IS_PRODUCTION_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_PROD_ROLLBACK_PROVISION: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          if [[ "$IS_PRODUCTION_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$IS_PROD_ROLLBACK_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "false" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, production or rollback provision request. But found values, prod provision? $IS_PRODUCTION_PROVISION, prod rollback provision? $IS_PROD_ROLLBACK_PROVISION"
            echo "Criteria-2, production environment."
            echo "Criteria-3, open milestone if production, closed milestone if rollback. But found values, milestone open? $IS_MILESTONE_OPEN"
            echo "failedReason=for prod request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - id: get-request-type
        env:
          IS_TESTPLAN_DEPROVISION: ${{ needs.run_eligible.outputs.is-testplan-deprovision }}
        run: |
          # since provision and deprovision conditions are verified appropriate to env, here we don't need to have repeatated conditions
          if [[ "$IS_TESTPLAN_DEPROVISION" == "true" ]]; then
            echo "request-type=deprovision" >> $GITHUB_OUTPUT
          else
            echo "request-type=provision" >> $GITHUB_OUTPUT
          fi
      - name: Checkout
        uses: actions/checkout@v4
      - id: get-milestone-testplan
        name: Validate Milestone and Branch
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // verify milestone branch exists
              console.log("issue has milestone title: ", context.payload.issue.milestone.title);
              // if milestone is open, there should be branch with milestone title
              if(context.payload.issue.milestone.state === "open") {
                if(!context.payload.issue.milestone.due_on) {
                  throw new Error("Milestone due date is not set");
                }
                const milestoneDueOn = new Date(context.payload.issue.milestone.due_on);
                if(milestoneDueOn < new Date()) {
                  throw new Error("Milestone due date is already passed");
                }
                const milestoneBranch = `milestone/${context.payload.issue.milestone.title}`;
                const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: milestoneBranch
                });
                console.log("getBranchResponse: ", getBranchResponse);
                const branchDetails = {
                  name: getBranchResponse.data.name, 
                  url: getBranchResponse.data._links.html
                };
                core.setOutput("branch", branchDetails); 
                core.setOutput("branch-name", branchDetails.name); 
                core.setOutput("branch-url", branchDetails.url);
                // verify milestone branch commit has merged all of the master branch
                const compareResponse = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: "master",
                  head: milestoneBranch
                });
                console.log("milestone branch as head and master branch as base, compareResponse: ", compareResponse);
                if (compareResponse.data.behind_by > 0) {
                  throw new Error(`Milestone branch [${milestoneBranch}] is behind master by ${compareResponse.data.behind_by} commits.`);
                }

              } else {
                // if milestone is closed, the master branch should have milestone version
                // compare package.json and milestone version
                const fs = require('fs');
                const packageJson = fs.readFileSync('package.json', 'utf8');
                const packageJsonObj = JSON.parse(packageJson);
                if(`v${packageJsonObj.version}` !== context.payload.issue.milestone.title) {
                  throw new Error(`Master branch package.json version [${packageJsonObj.version}] does not match with requested milestone version [${context.payload.issue.milestone.title}]`);
                }
                const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: "master"
                });
                const branchDetails = {
                  name: getBranchResponse.data.name, 
                  url: getBranchResponse.data._links.html
                };
                core.setOutput("branch", branchDetails);
                core.setOutput("branch-name", branchDetails.name);
                core.setOutput("branch-url", branchDetails.url);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: testplan-issue
        name: Validate Testplan issue
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // verify if regression label exists ? if so, set as output for further use
              const allowedTypes = ["regression"];
              const foundTypeLabel = context.payload.issue.labels.find(label=>allowedTypes.includes(label.name));
              core.setOutput("testplanType", foundTypeLabel?.name || "unknown");
              if(!foundTypeLabel) {
                throw new Error("Test plan type label not found in issue labels");
              }
              // find test plan issue with same milestone and type label
              const testplanIssueRegex = new RegExp(".+Test Plan:.+https://github.com/"+context.repo.owner+"/([^/]+)/issues/(\\d+).+", "i");
              if(!testplanIssueRegex.test(context.payload.issue.body)) {
                throw new Error("Test plan issue link not found")
              }
              const matchedGroups = testplanIssueRegex.exec(context.payload.issue.body);
              console.log("found match groups: ", matchedGroups);
              const testplanIssueRepo = matchedGroups[1];
              const testplanIssueNumber = matchedGroups[2];
              if(!testplanIssueNumber || !testplanIssueRepo) {
                throw new Error("Test plan issue link is not properly formatted.");
              }
              const allowedLabels = [foundTypeLabel.name, "test plan"];
              if(testplanIssueRepo === context.repo.repo) {
                const getIssueResponse = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: testplanIssueRepo,
                  issue_number: testplanIssueNumber
                });
                console.log("getIssueResponse: ", getIssueResponse);
                const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
                if(testplanLabels.length!==allowedLabels.length ||
                  getIssueResponse.data.state!=="open" || 
                  getIssueResponse.data.milestone.number!==context.payload.issue.milestone.number ) {
                  throw new Error("matching testplan issue not found")
                }
              }
              const testplanDetails = {
                  number: testplanIssueNumber,
                  repo: testplanIssueRepo,
                  allowedLabels: allowedLabels
              };
              core.setOutput("testplanIssue", testplanDetails);
              core.setOutput("testplanIssue-number", testplanDetails.number);
              core.setOutput("testplanIssue-repo", testplanDetails.repo);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: testplan-issue2
        name: Validate testplan issue from another repo
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_AWS_PAT }}
          script: |
            try {
              const testPlanIssueDetails = ${{ steps.testplan-issue.outputs.testplanIssue }};
              if(testPlanIssueDetails.repo === context.repo.repo) {
                console.log("already verified");
                return;
              }
              const getIssueResponse = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: testPlanIssueDetails.repo,
                issue_number: testPlanIssueDetails.number
              });
              console.log("getIssueResponse: ", getIssueResponse);
              const allowedLabels = testPlanIssueDetails.allowedLabels;
              const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
              if(testplanLabels.length!==allowedLabels.length || getIssueResponse.data.state!=="open" ) {
                 throw new Error("matching testplan issue not found");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: get-milestone-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Milestone and Branch
        uses: actions/github-script@v7
        env:
          IS_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                return centralTimeFormat.format(date);
              };
              const getBranch = async (branchName, tagName) => {
                try {
                  if(branchName) {
                    const getBranchResponse = await github.rest.repos.getBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      branch: branchName
                    });
                    console.log("getBranchResponse: ", getBranchResponse);
                    return getBranchResponse.data;
                  }
                  if(tagName) {
                    const getRefResponse = await github.rest.repos.getRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `tags/${tagName}`
                    });
                    console.log("getRefResponse: ", getRefResponse);
                    return getRefResponse.data;
                  }
                  throw new Error("requested neither branch nor tag");
                } catch(e) {
                  console.error("error during getBranch rest call", e);
                }
                return null;
              };
              // milestone due Date must be configured and is not past.
              if(!context.payload.issue.milestone.due_on) {
                throw new Error("Milestone due date is not set");
              }
              if(process.env.IS_ROLLBACK != "true") {
                // for prod deployment, date has to be today
                const milestoneDueOnDate = toTime(context.payload.issue.milestone.due_on).substring(0,10);
                if(milestoneDueOnDate !== toTime(new Date()).substring(0,10)) {
                  throw new Error("Milestone due date is not today");
                }
                // verify milestone branch not exists
                const milestoneBranch = await getBranch(`milestone/${context.payload.issue.milestone.title}`);
                if(milestoneBranch) {
                  throw new Error("milestone branch exist. It has to be merge to master and delete before prod deployment");
                }
              }
              // verify tag ref
              const tagRef = await getBranch(null, context.payload.issue.milestone.title);
              if(tagRef && process.env.IS_ROLLBACK != "true") {
                throw new Error(`for production deploy, tag [${context.payload.issue.milestone.title}] cannot exist.`);
              }
              if(!tagRef && process.env.IS_ROLLBACK == "true") {
                throw new Error(`for production rollback deploy, tag [${context.payload.issue.milestone.title}] not found.`);
              }
              core.setOutput("tagRefName", tagRef?.name);
              core.setOutput("tagRefUrl", tagRef?._links.html);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          cache: "pip" # caching pip dependencies
          python-version: "3.13"
      - id: request-form-testplan
        if: needs.run_eligible.outputs.is-testplan == 'true'
        name: Validate Request form details
        env:
          TESTPLAN_TYPE: ${{ steps.testplan-issue.outputs.testplanType || 'unknown' }}
        run: |
          echo '${{ toJson(github.event.issue) }}' > request_form_issue_details.json
          echo '${{ steps.get-milestone-testplan.outputs.branch }}' > branch_details.json
          python --version
          pip install -r .github/scripts/requirements.txt
          set +e
          python .github/scripts/testplan_deploy_request.py --validate \
              --request-form-issue-details "request_form_issue_details.json" \
              --testplan-type "$TESTPLAN_TYPE" \
              --branch-details "branch_details.json" > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - id: request-form-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Request Form Details
        run: |
          echo '${{ toJson(github.event.issue) }}' > request_form_issue_details.json
          python --version
          pip install -r .github/scripts/requirements.txt
          set +e
          python .github/scripts/prod_deploy_request.py --validate \
              --request-form-issue-details "request_form_issue_details.json"  > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - name: Validate Rollback
        if: needs.run_eligible.outputs.is-prod-rollback == 'true'
        uses: actions/github-script@v7
        env:
          EXISTING_VERSION: ${{ steps.request-form-prod.outputs.existing_version }}
        with:
          script: |
            try {
              // find related issue of release form
              // verify rollback version is immediate valid previous version, milestone and tag
              const listMilestonesResponse = await github.rest.issues.listMilestones({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: "all"
              });
              console.log("listMilestonesResponse: ", listMilestonesResponse);
              const deployedMilestone=listMilestonesResponse.data.find(mlst=>mlst.title===process.env.EXISTING_VERSION);
              if(!deployedMilestone) {
                throw new Error("deployed milestone is not found");
              }
              const listIssuesResponse = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ["deployment", "production"],
                state: "closed",
                milestone: deployedMilestone.number
              });
              console.log("listIssuesResponse: ", listIssuesResponse);
              const releasedRequest = listIssuesResponse.data.find(iss=>iss.title.startsWith("[Approved] [Request] Provision Production Environment"));
              if(!releasedRequest) {
                throw new Error("prod release request form not found");
              }
              const versionRegex = /^v\d+\.\d+\.\d+$/;
              // filter by open status and due date is today
              const releaseMilestone = listMilestonesResponse.data.find(mlstn=> {
                if(versionRegex.test(mlstn.title) && mlstn.state === "open") {
                  if(new Date(mlstn.due_on).toLocaleDateString() === new Date().toLocaleDateString()) {
                    return true;
                  }
                }
                return false;
              });
              if(!releaseMilestone) {
                throw new Error("release milestone is not found.");
              }
              if(releaseMilestone.title !== process.env.EXISTING_VERSION) {
                throw new Error("releasing milestone version is not same as provided existing version");
              }
              const validVersionsAfterRollback = listMilestonesResponse.data
                        .filter(mlstn=>mlstn.title>context.payload.issue.milestone.title && mlstn.title<=releaseMilestone.title)
                        .filter(mlstn=>versionRegex.test(mlstn.title))
                        .map(mlstn=>mlstn.title)
                        .sort();
              if(validVersionsAfterRollback[0]!==releaseMilestone.title) {
                const expectedRollbackVersionMessage = validVersionsAfterRollback[0]? "Expected rollback, " + validVersionsAfterRollback[0]: "No rollback version found";
                throw new Error("Invalid Rollback version is defined. cannot fulfill the request. " + expectedRollbackVersionMessage);
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  validate_request_stack:
    name: Validate Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
    outputs:
      failed-reason: ${{ steps.provision-stack-testplan.outputs.failedReason || steps.deprovision-stack-testplan.outputs.failedReason || steps.provision-stack-prod.outputs.failedReason }}
      stack-details: ${{ steps.provision-stack-testplan.outputs.stack_details || steps.deprovision-stack-testplan.outputs.stack_details || steps.provision-stack-prod.outputs.stack_details || '{}' }}
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: provision-stack-prod
        name: Verify branch is deployable
        if: >
          needs.validate_request.outputs.request-type == 'provision' &&
          needs.run_eligible.outputs.is-production == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ ! "$STACK_STATUS" =~ _COMPLETE$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is not complete, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: provision-stack-testplan
        name: Verify branch is deployable
        if: >
          needs.validate_request.outputs.request-type == 'provision' &&
          needs.run_eligible.outputs.is-testplan == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISS_REPO: ${{ needs.validate_request.outputs.testplan-issue-repo }}
          TESTPLAN_ISS_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ ! "$STACK_STATUS" =~ _COMPLETE$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is not complete, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check milestone 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Type 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanType").Value')
          if [[ "$TAG_VALUE" != "$TESTPLAN_TYPE" ]]; then
            FAILED_REASON="The testplan type doesnot match. Found $TAG_VALUE testplan type."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Issue number 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanIssueNumber").Value')
          EXPECTED_TESTPLAN_ISS="$TESTPLAN_ISS_REPO/issue-$TESTPLAN_ISS_NUMBER"
          if [[ "$TAG_VALUE" != "$EXPECTED_TESTPLAN_ISS" ]]; then
            FAILED_REASON="The stack is deployed for another testplan issue, $TAG_VALUE, instead of $EXPECTED_TESTPLAN_ISS."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: deprovision-stack-testplan
        if: >
          needs.validate_request.outputs.request-type == 'deprovision' &&
          needs.run_eligible.outputs.is-testplan
        name: Verify branch is destroyable
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"  
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Infra Stack does not exist. given branch for milestone has already been destroyed."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          ENV_TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags[?Key=='environment'].Value")
          if [[ "$ENV_TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $ENV_TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          MILESTONE_TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags[?Key=='milestone'].Value")
          if [[ "$MILESTONE_TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $MILESTONE_TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  create_tag:
    name: Create Tag
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_request_stack
    outputs:
      failed-reason: ${{ steps.no-branch.outputs.failedReason || steps.create-prod-tag.outputs.failedReason }}
      branch-tag-name: ${{ needs.validate_request.outputs.branch-name || github.event.issue.milestone.title }}
    steps:
      - id: no-branch
        env:
          BRANCH_NAME: ${{ needs.validate_request.outputs.branch-name }}
          IS_PROD_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_PROD_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
        run: |
          if [[ -z "$BRANCH_NAME" ]]; then
            if [[ "$IS_PROD_ROLLBACK" == "true" ]]; then
              FAILED_REASON="Tag for prod rollback is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
            if [[ "$IS_TESTPLAN" == "true" ]]; then
              FAILED_REASON="Milestone Branch is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
          elif [[ "$IS_PROD_PROVISION" == "true" ]]; then
            FAILED_REASON="Tag cannot be available for prod."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "$FAILED_REASON"
            exit 1
          fi
      - name: Checkout
        uses: actions/checkout@v4
      - id: create-prod-tag
        name: Create Tag
        if: needs.run_eligible.outputs.is-prod-provision == 'true'
        env:
          TAG_VER: ${{ github.event.issue.milestone.title }}
        run: |
          LOG_FILE="create_tag.failed.log"
          if ! git tag -a "$TAG_VER" -m "Release $TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to create tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi
          if ! git push origin "$TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to push tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi

  diff:
    name: Infra Stack Diff
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - create_tag
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      stack-tags: ${{ steps.prepare-tags.outputs.stackTags }}
    steps:
      - name: Display Needs
        run: |
          echo "Needs of Validate Request: ${{ toJson(needs.validate_request) }}"
          echo "Needs of Update Request: ${{ toJson(needs.update_request) }}"
          echo "Milestone branch name: ${{ needs.validate_request.outputs.branch-name }}"
          echo "Testplan Type: ${{ needs.validate_request.outputs.testplan-type }}"
          echo "Testplan Issue Number: ${{ needs.validate_request.outputs.testplan-issue-number }}"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create_tag.outputs.branch-tag-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          pwd
          mkdir -p dist/ui
          echo ls -lrt
          ls -lrt
          echo ls -lrt dist
          ls -lrt dist
          echo ls -lrt ../
          ls -lrt ../
      - id: prepare-tags
        uses: actions/github-script@v7
        env:
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          TESTPLAN_ISSUE_REPO: ${{ needs.validate_request.outputs.testplan-issue-repo }}
        with:
          script: |
            const stackTags = [];
            stackTags.push(`workflow_run_id=${context.runId}`);
            stackTags.push(`milestone=${context.payload.issue.milestone.title}`);
            if(process.env.TESTPLAN_TYPE && process.env.TESTPLAN_ISSUE_REPO && process.env.TESTPLAN_ISSUE_NUMBER) {
              stackTags.push(`testplanType=${process.env.TESTPLAN_TYPE}`);
              stackTags.push(`testplanIssueNumber=${process.env.TESTPLAN_ISSUE_REPO}/issue-${process.env.TESTPLAN_ISSUE_NUMBER}`);
            }
            stackTags.push(`requestIssueNumber=${context.repo.repo}/issue-${context.payload.issue.number}`);
            core.setOutput("stackTags", stackTags);
      - run: |
          echo "Infra Stack TAGS: ${{ toJson(steps.prepare-tags.outputs.stackTags) }}"
          echo "Infra Stack TAGS: ${{ join(steps.prepare-tags.outputs.stackTags) }}"
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: cdk diff
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "diff"
          actions_comment: false
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ join(steps.prepare-tags.outputs.stackTags) }}

  deployment:
    name: Deploy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - diff
      - create_tag
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.deploying-comment.outputs.failedReason || steps.describe-stack.outputs.failedReason || steps.update-issue-deploy-complete.outputs.failedReason }}
    steps:
      - name: Display Needs
        run: |
          echo "Needs of Validate Request: ${{ toJson(needs.validate_request) }}"
          echo "Needs of Update Request: ${{ toJson(needs.update_request) }}"
          echo "Needs of Diff: ${{ toJson(needs.diff) }}"
          echo "from validate request, Milestone branch name: ${{ needs.validate_request.outputs.branch-name }}"
          echo "from validate request, Testplan Type: ${{ needs.validate_request.outputs.testplan-type }}"
          echo "from update request, Original Issue Title: ${{ needs.update_request.outputs.original-issue-title }}"
          echo "from validate request, Stack Details: ${{ needs.validate_request.outputs.stack-details }}"
          echo "from validate request, Stack Details: ${{ toJson(needs.validate_request.outputs.stack-details) }}"
          echo "from diff, Stack Tags: ${{ join(needs.diff.outputs.stack-tags) }}"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create_tag.outputs.branch-tag-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm --version
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          cd dist/lambda_layer/nodejs
          npm install .
          cd ../../..
          mkdir -p dist/ui
          # touch dist/ui/dummy.txt
          pwd
          echo ls -lrt
          ls -lrt
          echo ls -lrt dist
          ls -lrt dist
          echo ls -lrt dist/ui
          ls -lrt dist/ui
          echo ls -lrt ../
          ls -lrt ../
      - id: deploying-comment
        name: Update Issue - Deploying
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.create_tag.outputs.branch-tag-name }}
          IS_FOR_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                return centralTimeFormat.format(date);
              };
              const deploymentStartTime = new Date().toISOString();
              core.setOutput("deploymentStartTime", deploymentStartTime);
              const commentBody = [
                "## Infra Deployment Started",
                "", "### Start Time: ", "",
                "  " + toTime(deploymentStartTime)
              ];
              if("true" == process.env.IS_FOR_TESTPLAN) {
                commentBody.push("", "### Milestone Branch: ", "");
              } else {
                commentBody.push("", "### Tag: ", "");
              }
              commentBody.push("  " + process.env.MILESTONE_BRANCH_NAME);

              const stackDetails = ${{ needs.validate_request_stack.outputs.stack-details }};
              commentBody.push("", "### API Stack: ", "");
              
              if(stackDetails?.api) {
                // audit details available
                commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
                commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              } else {
                commentBody.push("API Stack is not found. It seems to be first deployment.");
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the deployment to complete. This issue will be updated with deployment status.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment start comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: cdk-deploy
        name: cdk deploy
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "deploy"
          cdk_stack: "MyFinanceInfraStack"
          debug_log: true
          actions_comment: false
          cdk_args: "--require-approval never --exclusively"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ join(needs.diff.outputs.stack-tags) }}
        continue-on-error: true
      - id: describe-stack
        name: Describe stack
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          CDK_DEPLOY_OUTCOME: ${{ steps.cdk-deploy.outcome }}
        run: |
          echo "cdk deploy outcome: $CDK_DEPLOY_OUTCOME"
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "failedReason=Failed to describe stack. Error: $DESCRIBE_STACK_OUT" >> $GITHUB_OUTPUT
            exit $RET_CODE
          fi
          if [ "$CDK_DEPLOY_OUTCOME" == "failure" ]; then
            STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="CDK deployment failed. please check logs for details. Stack Status is $STACK_STATUS and Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          STACK_OUTPUTS=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Outputs")
          STACK_AUDIT='{"api":'$API_STACK_AUDIT',"outputs":'$STACK_OUTPUTS'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: update-issue-deploy-complete
        name: Update Issue - Deployment Complete
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_START_TIME: ${{ steps.deploying-comment.outputs.deploymentStartTime }}
        with:
          script: |
            try {
              console.log("Deployment Start Time: ", process.env.DEPLOYMENT_START_TIME);
              const stackDetails = ${{ steps.describe-stack.outputs.stack_details }};
              console.log("Stack Details: ", stackDetails);
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                return centralTimeFormat.format(date);
              };
              const deploymentEndTime = new Date();
              const diffParts = new Date(deploymentEndTime - new Date(process.env.DEPLOYMENT_START_TIME)).toISOString().substr(11, 8).split(":");
              const getNonZero = (value, suffix) => {
                const pluralS = value>1? "s" : "";
                if(value>0) { 
                  return `${value} ${suffix}${pluralS}`; 
                }
                return "";
              };
              let duration = "";
              duration += getNonZero(parseInt(diffParts[0]), "hour") + " ";
              duration += getNonZero(parseInt(diffParts[1]), "minute") + " ";
              duration += getNonZero(parseInt(diffParts[2]), "second") + " ";
              
              const commentBody = [
                "## Infra Deployment Completed",
                "<br/>", 
                "", "### Deployment Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${toTime(process.env.DEPLOYMENT_START_TIME)} |`,
                `| **End Time** | ${toTime(deploymentEndTime.toISOString())} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];
              
              commentBody.push("", "### Stack Outputs: ", "");
              stackDetails?.outputs.forEach(output => {
                commentBody.push(` - **${output.OutputKey}:** ${output.OutputValue}  `);
              });
              if(stackDetails?.outputs.length === 0) {
                commentBody.push("  No outputs found.");
              }
              commentBody.push("", "### Stack Audit: ", "");
              
              if(stackDetails?.api) {
                // audit details available
                commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
                commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The deployment is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment complete comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  destroy:
    name: Destroy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - update_request
      - validate_request
    if: needs.validate_request.outputs.request-type == 'deprovision'
    outputs:
      failed-reason: ${{ steps.validate-destroy.outputs.failedReason }}
    steps:
      - id: validate-destroy
        run: |
          FAILED_REASON="The Request of Destroy Infra Stack is not supported yet."
          echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
          echo "Failed Reason: $FAILED_REASON"
          exit 1

  handle_failure:
    name: Handle Request form Failure
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - create_tag
      - diff
      - deployment
      - destroy
    if: failure()
    steps:
      - run: |
          echo 'Run Eligible: ${{ toJson(needs.run_eligible) }}'
          echo 'Update Request: ${{ toJson(needs.update_request) }}'
          echo 'Validate Request: ${{ toJson(needs.validate_request) }}'
          echo 'Validate Request Stack: ${{ toJson(needs.validate_request_stack) }}'
          echo 'Create Tag: ${{ toJson(needs.create_tag) }}'
          echo 'Diff: ${{ toJson(needs.diff) }}'
          echo 'Deployment: ${{ toJson(needs.deployment) }}'
          echo 'Destroy: ${{ toJson(needs.destroy) }}'
      - if: needs.run_eligible.result == 'failure'
        run: |
          echo "Since run eligible job failed, skipping fail handler job"
          exit 1
      - id: prepare-error
        uses: actions/github-script@v7
        env:
          VALIDATION_FAIL_REASON: ${{ needs.update_request.outputs.failed-reason || needs.validate_request.outputs.failed-reason || needs.validate_request_stack.outputs.failed-reason }}
          IS_VALIDATION_FAILED: ${{ needs.update_request.result == 'failure' || needs.validate_request.result == 'failure' || needs.validate_request_stack.result == 'failure' || needs.diff.result == 'failure' }}
          DEPLOY_FAILED_REASON: ${{ needs.create_tag.outputs.failed-reason || needs.deployment.outputs.failed-reason }}
          IS_DEPLOY_FAILED: ${{ needs.deployment.result == 'failure' || needs.create_tag.result == 'failure' }}
          DESTROY_FAILED_REASON: ${{ needs.destroy.outputs.failed-reason }}
          IS_DESTROY_FAILED: ${{ needs.destroy.result == 'failure' }}
        with:
          script: |
            let errorDetails= "Found unknown error. Please check the logs.";
            if(String(process.env.IS_VALIDATION_FAILED) === "true") {
              errorDetails = process.env.VALIDATION_FAIL_REASON || errorDetails;
              core.setOutput("reason", "Validation of Api Request form is failed.");
              core.setOutput("status", "Denied");
            } else if(String(process.env.IS_DEPLOY_FAILED) === "true") {
              errorDetails = process.env.DEPLOY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Deployment of Infra stack is failed.");
              core.setOutput("status", "Failed");
            } else if(String(process.env.IS_DESTROY_FAILED) === "true") {
              errorDetails = process.env.DESTROY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Destroy of Infra Stack is failed.");
              core.setOutput("status", "Failed");
            } else {
              throw new Error("could not find any fail job");
            }
            core.setOutput("details", errorDetails);
      - name: Add Failed Reason as Comment
        uses: actions/github-script@v7
        env:
          FAIL_REASON: ${{ steps.prepare-error.outputs.reason }}
          ERROR_DETAILS: ${{ steps.prepare-error.outputs.details }}
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
        with:
          script: |
            const commentBody = [
                    "## Request " + process.env.FAIL_STATUS, 
                    "", "### Reason:", "",
                    "  " + process.env.FAIL_REASON, "",
                    "**Error:**  " + process.env.ERROR_DETAILS, 
                    "<br/>",  "",
                    "> [!NOTE]",
                    "> **Needs Action:**   Please raise a `new request form` with correct details. This request issue will be `closed`.",
                    "<br/>", "<br/>",  "",
                  ];
            const workflowTitle = context.workflow +" (" + context.runId + ")";
            const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
            commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

            console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
            const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
            });
            console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
            const commentResponse = github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody.join("\n")
            });
            console.log("commentResponse: ", commentResponse);
      - name: Close Issue
        uses: actions/github-script@v7
        env:
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            const closeUpdateResponse = await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              state: 'closed',
              title: "[" + process.env.FAIL_STATUS + "]" + process.env.ORIGINAL_ISSUE_TITLE,
            });
            console.log("closeUpdateResponse: ", closeUpdateResponse);
            const lockIssueResponse = await github.rest.issues.lock({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number
            });
            console.log("issue is lock again, lock issue response:", lockIssueResponse);
