# This workflow performs basic steps
# build, compile, synth and unit test
name: AWS Infra Deploy

on:
  issues:
    types:
      - opened
      - deleted

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.milestone.number }}-${{ github.event.issue.number }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read
  issues: write

jobs:
  display_output:
    name: Display Output
    runs-on: ubuntu-latest
    steps:
      # https://docs.github.com/en/webhooks/webhook-events-and-payloads#issues
      - run: |
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue id: ${{ github.event.issue.id }}"
      - run: |
          echo "Issue title: ${{ github.event.issue.title }}"
      - run: |
          echo "Issue body: ${{ github.event.issue.body }}"
      - run: |
          echo "Issue milestone: ${{ github.event.issue.milestone }}"
          echo "Issue milestone title: ${{ github.event.issue.milestone.title }}"
      - run: |
          echo "Issue state: ${{ github.event.issue.state }}"
          echo "Issue state reason: ${{ github.event.issue.state_reason }}"
      - run: |
          echo "Issue draft: ${{ github.event.issue.draft }}"
          echo "Issue locked: ${{ github.event.issue.locked }}"
          echo "Issue active lock reason: ${{ github.event.issue.active_lock_reason }}"
      - run: |
          echo "Issue labels name: ${{ github.event.issue.labels.*.name }}"
      - run: |
          echo "Issue total comments: ${{ github.event.issue.comments }}"
      - run: |
          echo "Issue updated at: ${{ github.event.issue.updated_at }}"
          echo "Issue closed at: ${{ github.event.issue.closed_at }}"
          echo "Issue created at: ${{ github.event.issue.created_at }}"
      - run: |
          echo "Issue author association: ${{ github.event.issue.author_association }}"
      - run: |
          echo "Issue sender login: ${{ github.event.sender.login }}"
          echo "Issue sender type: ${{ github.event.sender.type }}"
          echo "Issue sender id: ${{ github.event.sender.id }}"
          echo "Issue sender view type: ${{ github.event.sender.user_view_type }}"
      - run: |
          echo "Issue user login: ${{ github.event.issue.user.login }}"
          echo "Issue user type: ${{ github.event.issue.user.type }}"
          echo "Issue user id: ${{ github.event.issue.user.id }}"
          echo "Issue user view type: ${{ github.event.issue.user.user_view_type }}"
      - run: |
          echo "Issue assignee login: ${{ github.event.issue.assignee.login }}"
          echo "Issue assignee type: ${{ github.event.issue.assignee.type }}"
          echo "Issue assignee id: ${{ github.event.issue.assignee.id }}"
          echo "Issue assignee view type: ${{ github.event.issue.assignee.user_view_type }}"
      - run: |
          echo "github actor: ${{ github.actor }}"
          echo "github triggering actor: ${{ github.triggering_actor }}"
          echo "Issue perfomed by app: ${{ github.event.issue.performed_via_github_app }}"
      - run: |
          echo "action: ${{ github.action }}"
          echo "event name: ${{ github.event_name }}"
          echo "event changes: ${{ github.event.changes }}"
          echo "event action: ${{ github.event.action }}"
      - run: |
          echo 'github json: ${{ toJson(github) }}'
      - uses: actions/github-script@v7
        with:
          script: |
            console.log("Context obj: ", context);
            console.log("Github config: ", github)
            console.log("Github Rest API config: ", github.rest)
            console.log("Github Rest Issues API:", github.rest.issues)

  update_request:
    name: Start Request
    runs-on: ubuntu-latest
    if: >
      contains(github.event.issue.labels.*.name, 'deployment') &&
      github.event.issue.milestone != null &&
      (
        contains(github.event.issue.labels.*.name, 'test plan') && (
        startsWith(github.event.issue.title, '[Request] Provision Test Plan Environment') ||
        startsWith(github.event.issue.title, '[Request] Deprovision Test Plan Environment') )
        ) &&
        (
          contains(github.event.issue.labels.*.name, 'production') && (
          startsWith(github.event.issue.title, '[Request] Provision Production Environment') ||
          startsWith(github.event.issue.title, '[Request] Deprovision Production Environment') )
      ) &&
      startsWith(github.event.issue.author_association, 'OWNER')
    outputs:
      failed-reason: ${{ steps.update_request.outputs.failedReason || steps.env-request.outputs.failedReason }}
      env-type: ${{ steps.env-request.outputs.env_type }}
      original-issue-title: ${{ steps.update_issue_start.outputs.issue-title }}
    steps:
      - run: |
          echo "The issue has milestone assigned and locked."
          echo "The issue has required labels (deployment, test plan)."
          echo "This request form is raised by owner."
          echo "This request form title indicates that It is related to provision or deprovision test plan environment."
          echo "We will validate request form issue details."
      - id: update_request
        name: Update Issue - Start Processing
        uses: actions/github-script@v7
        with:
          script: |
            try {
              core.setOutput("issue-title", context.payload.issue.title);
              const updateResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Processing] " + context.payload.issue.title
              });
              console.log("updateResponse: ", updateResponse);
              if(!context.payload.issue.locked) {
                const lockIssueResponse = await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number
                });
                console.log("Lock issue response:", lockIssueResponse);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: env-request
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const allowedTypes = ["test plan", "production"];
              const foundTestplanLabel = context.payload.issue.labels.find(label=>label.name === "test plan");
              const foundProductionLabel = context.payload.issue.labels.find(label=>label.name === "production");
              if(!foundTestplanLabel && !foundProductionLabel) {
                throw new Error("Environemt is not specified in Request issue labels");
              }
              if(foundTestplanLabel && foundProductionLabel) {
                throw new Error("Both test plan and production labels are found in Request issue labels");
              }
              if(foundTestplanLabel) {
                core.setOutput("env_type", "testplan");
              } else {
                core.setOutput("env_type", "production");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during Env request validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  validate_request:
    name: Validate Request Form
    runs-on: ubuntu-latest
    needs:
      - update_request
    outputs:
      milestone-branch: ${{ steps.get-milestone.outputs.branch }}
      failed-reason: ${{ steps.get-milestone.outputs.failedReason || steps.testplan-issue.outputs.failedReason || steps.testplan-issue2.outputs.failedReason || steps.request-form.outputs.failedReason || steps.provision-stack.outputs.failedReason || steps.deprovision-stack.outputs.failedReason }}
      testplan-type: ${{ steps.testplan-issue.outputs.testplanType }}
      request-type: ${{ steps.request-form.outputs.request_type }}
      testplan-issue-number: ${{ steps.testplan-issue.outputs.testplanIssue.number || steps.request-form.outputs.testplan_issue_number }}
      testplan-issue-repo: ${{ steps.testplan-issue.outputs.testplanIssue.repo }}
      stack-details: ${{ steps.provision-stack.outputs.stack_details || steps.deprovision-stack.outputs.stack_details || '{}' }}
    environment:
      name: aws-infra-${{ needs.update_request.outputs.env-type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - id: get-milestone
        name: Validate Milestone and Branch
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // verify milestone branch exists
              console.log("issue has milestone title: ", context.payload.issue.milestone.title);
              // if milestone is open, there should be branch with milestone title
              if(context.payload.issue.milestone.state === "open") {
                if(!context.payload.issue.milestone.due_on) {
                  throw new Error("Milestone due date is not set");
                }
                const milestoneDueOn = new Date(context.payload.issue.milestone.due_on);
                if(milestoneDueOn < new Date()) {
                  throw new Error("Milestone due date is already passed");
                }
                const milestoneBranch = `milestone/${context.payload.issue.milestone.title}`;
                const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: milestoneBranch
                });
                console.log("getBranchResponse: ", getBranchResponse);
                core.setOutput("branch", {
                  name: getBranchResponse.data.name, 
                  url: getBranchResponse.data._links.html
                });
                // verify milestone branch commit has merged all of the master branch
                const compareResponse = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: "master",
                  head: milestoneBranch
                });
                console.log("milestone branch as base and master branch as head, compareResponse: ", compareResponse);
                if (compareResponse.data.behind_by > 0) {
                  throw new Error(`Milestone branch [${milestoneBranch}] is behind master by ${compareResponse.data.behind_by} commits.`);
                }

              } else {
                // if milestone is closed, the master branch should have milestone version
                // compare package.json and milestone version
                const fs = require('fs');
                const packageJson = fs.readFileSync('package.json', 'utf8');
                const packageJsonObj = JSON.parse(packageJson);
                if(`v${packageJsonObj.version}` !== context.payload.issue.milestone.title) {
                  throw new Error(`Master branch package.json version [${packageJsonObj.version}] does not match with requested milestone version [${context.payload.issue.milestone.title}]`);
                }
                const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: "master"
                });
                core.setOutput("branch", {
                  name: getBranchResponse.data.name, 
                  url: getBranchResponse.data._links.html
                });
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: testplan-issue
        name: Validate Testplan issue
        if: contains(github.event.issue.labels.*.name, 'test plan')
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // verify if regression label exists ? if so, set as output for further use
              const allowedTypes = ["regression"];
              const foundTypeLabel = context.payload.issue.labels.find(label=>allowedTypes.includes(label.name));
              core.setOutput("testplanType", foundTypeLabel?.name || "unknown");
              if(!foundTypeLabel) {
                throw new Error("Test plan type label not found in issue labels");
              }
              // find test plan issue with same milestone and type label
              const testplanIssueRegex = new RegExp(".+Test Plan:.+https://github.com/"+context.repo.owner+"/([^/]+)/issues/(\\d+).+", "i");
              if(!testplanIssueRegex.test(context.payload.issue.body)) {
                throw new Error("Test plan issue link not found")
              }
              const matchedGroups = testplanIssueRegex.exec(context.payload.issue.body);
              console.log("found match groups: ", matchedGroups);
              const testplanIssueRepo = matchedGroups[1];
              const testplanIssueNumber = matchedGroups[2];
              if(!testplanIssueNumber || !testplanIssueRepo) {
                throw new Error("Test plan issue link is not properly formatted.");
              }
              const allowedLabels = [foundTypeLabel.name, "test plan"];
              if(testplanIssueRepo === context.repo.repo) {
                const getIssueResponse = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: testplanIssueRepo,
                  issue_number: testplanIssueNumber
                });
                console.log("getIssueResponse: ", getIssueResponse);
                const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
                if(testplanLabels.length!==allowedLabels.length ||
                  getIssueResponse.data.state!=="open" || 
                  getIssueResponse.data.milestone.number!==context.payload.issue.milestone.number ) {
                  throw new Error("matching testplan issue not found")
                }
              }
              core.setOutput("testplanIssue", {
                  number: testplanIssueNumber,
                  repo: testplanIssueRepo,
                  allowedLabels: allowedLabels
              });
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Validate testplan issue from another repo
        id: testplan-issue2
        if: contains(github.event.issue.labels.*.name, 'test plan')
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_AWS_PAT }}
          script: |
            try {
              const testPlanIssueDetails = ${{ steps.testplan-issue.outputs.testplanIssue }};
              if(testPlanIssueDetails.repo === context.repo.repo) {
                console.log("already verified");
                return;
              }
              const getIssueResponse = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: testPlanIssueDetails.repo,
                issue_number: testPlanIssueDetails.number
              });
              console.log("getIssueResponse: ", getIssueResponse);
              const allowedLabels = testPlanIssueDetails.allowedLabels;
              const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
              if(testplanLabels.length!==allowedLabels.length ||
                 getIssueResponse.data.state!=="open" || 
                 getIssueResponse.data.milestone.number!==context.payload.issue.milestone.number ) {
                 throw new Error("matching testplan issue not found")
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          cache: "pip" # caching pip dependencies
          python-version: "3.13"
      - id: request-form
        name: Validate Request form details
        env:
          TESTPLAN_TYPE: ${{ steps.testplan-issue.outputs.testplanType || 'unknown' }}
        run: |
          echo '${{ github.event.issue }}' > request_form_issue_details.json
          echo '${{ steps.get-milestone.outputs.branch }}' > branch_details.json
          python --version
          pip install -r .github/scripts/requirements.txt
          set +e
          python .github/scripts/deploy_request.py --validate \
              --request-form-issue-details "request_form_issue_details.json" \
              --testplan-type "$TESTPLAN_TYPE" \
              --branch-details "branch_details.json" > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: provision-stack
        if: ${{ steps.request-form.outputs.request_type == 'provision' }}
        name: Verify branch is deployable
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi

          ENV_TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags[?Key=='environment'].Value")
          if [[ "$ENV_TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $ENV_TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          MILESTONE_TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags[?Key=='milestone'].Value")
          if [[ "$MILESTONE_TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $MILESTONE_TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":'$API_CREATED_TIME',"updated_time":'$API_UPDATED_TIME'}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: deprovision-stack
        if: ${{ steps.request-form.outputs.request_type == 'deprovision' }}
        name: Verify branch is destroyable
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"  
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Infra Stack does not exist. given branch for milestone has already been destroyed."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          ENV_TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags[?Key=='environment'].Value")
          if [[ "$ENV_TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $ENV_TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          MILESTONE_TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags[?Key=='milestone'].Value")
          if [[ "$MILESTONE_TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $MILESTONE_TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":'$API_CREATED_TIME',"updated_time":'$API_UPDATED_TIME'}'
          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  diff:
    name: Infra Stack Diff
    runs-on: ubuntu-latest
    needs:
      - update_request
      - validate_request
    environment:
      name: aws-infra-${{ needs.update_request.outputs.env-type }}
    outputs:
      stack-tags: ${{ steps.prepare-tags.outputs.stackTags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_request.outputs.milestone-branch.name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          mkdir -p dist/ui
      - id: prepare-tags
        uses: actions/github-script@v7
        env:
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
        with:
          script: |
            const stackTags = [];
            stackTags.push(`workflow_run_id=${context.runId}`);
            stackTags.push(`milestone=${context.payload.issue.milestone.title}`);
            stackTags.push(`testplanType=${process.env.TESTPLAN_TYPE}`);
            stackTags.push(`testplanIssueNumber=${process.env.TESTPLAN_ISSUE_NUMBER}`);
            stackTags.push(`requestIssueNumber=${context.payload.issue.number}`);
            core.setOutput("stackTags", stackTags);
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: cdk diff
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "diff"
          actions_comment: false
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ join(steps.prepare-tags.outputs.stackTags, ',') }}

  deployment:
    name: Deploy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - update_request
      - validate_request
      - diff
    environment:
      name: aws-infra-${{ needs.update_request.outputs.env-type }}
    outputs:
      failed-reason: ${{ steps.deploying-comment.outputs.failedReason || steps.describe-stack.outputs.failedReason || steps.update-issue-deploy-complete.outputs.failedReason }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_request.outputs.milestone-branch.name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm --version
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          cd dist/lambda_layer/nodejs
          npm install .
          mkdir -p dist/ui
      - id: deploying-comment
        name: Update Issue - Deploying
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.validate_request.outputs.milestone-branch.name }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.update_request.outputs.original-issue-title }}
        with:
          script: |
            try {
              const deploymentStartTime = new Date().toISOString();
              core.setoutput("deploymentStartTime", deploymentStartTime);
              const commentBody = [
                "## Infra Deployment Started",
                "<br/>", 
                "", "### Start Time: ", "",
                "  " + deploymentStartTime, 
                "", "### Milestone Branch: ", "",
                "  " + process.env.MILESTONE_BRANCH_NAME
              ];

              const stackDetails = ${{ needs.validate_request.outputs.stack-details }};
              commentBody.push("", "### API Stack: ", "");
              if(stackDetails?.api) {
                // audit details available
                commentBody.push("- **Created On:**  " + stackDetails.api.created_time);
                commentBody.push("- **Updated On:**  " + stackDetails.api.updated_time);
              } else {
                commentBody.push("API Stack is not found. It seems to be first deployment.");
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the deployment to complete. This issue will be updated with deployment status.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment start comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: cdk-deploy
        name: cdk deploy
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "deploy"
          cdk_stack: "MyFinanceInfraStack"
          debug_log: true
          actions_comment: false
          cdk_args: "--require-approval never --exclusively"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ needs.diff.outputs.stack-tags }}
        continue-on-error: true
      - id: describe-stack
        run: |
          if [ "${{ steps.cdk-deploy.outcome }}" == "failure" ]; then
            echo "failedReason=CDK deployment failed. Check the logs for more details." >> $GITHUB_OUTPUT
            exit 1
          fi
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          if [[ $RET_CODE -ne 0 ]]; then
            echo "failedReason=Failed to describe stack. Error: $DESCRIBE_STACK_OUT" >> $GITHUB_OUTPUT
            exit $RET_CODE
          fi
          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":'$API_CREATED_TIME',"updated_time":'$API_UPDATED_TIME'}'
          STACK_OUTPUTS=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Outputs")
          STACK_AUDIT='{"api":'$API_STACK_AUDIT',"outputs":'$STACK_OUTPUTS'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: update-issue-deploy-complete
        name: Update Issue - Deployment Complete
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.validate_request.outputs.milestone-branch.name }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          DEPLOYMENT_START_TIME: ${{ steps.deploying-comment.outputs.deploymentStartTime }}
        with:
          script: |
            try {
              const deploymentEndTime = new Date();
              const diffParts = new Date(new Date() - new Date(process.env.DEPLOYMENT_START_TIME)).toISOString().substr(11, 8).split(":");
              let duration = "";
              if(parseInt(diffParts[0]) > 0) {
                duration += diffParts[0] + " hour" + (diffParts[0] > 1 ? "s " : " ");
              }
              if(parseInt(diffParts[1]) > 0) {
                duration += diffParts[1] + " minute" + (diffParts[1] > 1 ? "s " : " ");
              }
              if(parseInt(diffParts[2]) > 0) {
                duration += diffParts[2] + " second" + (diffParts[2] > 1 ? "s " : " ");
              }
              const commentBody = [
                "## Infra Deployment Completed",
                "<br/>", 
                "", "### Deployment Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${process.env.DEPLOYMENT_START_TIME} |`,
                `| **End Time** | ${deploymentEndTime.toISOString()} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];
              const stackDetails = ${{ steps.describe-stack.outputs.stack_details }};
              commentBody.push("", "### Stack Outputs: ", "");
              stackDetails?.outputs.forEach(output => {
                commentBody.push(` - **${output.OutputKey}:** ${output.OutputValue}  `);
              });
              if(stackDetails?.outputs.length === 0) {
                commentBody.push("  No outputs found.");
              }
              commentBody.push("", "### Stack Audit: ", "");
              if(stackDetails?.api) {
                // audit details available
                commentBody.push("- **Created On:**  " + stackDetails.api.created_time);
                commentBody.push("- **Updated On:**  " + stackDetails.api.updated_time);
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The deployment is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment complete comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  destroy:
    name: Destroy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - update_request
      - validate_request
    if: needs.validate_request.outputs.request-type == 'deprovision'
    outputs:
      failed-reason: ${{ steps.validate-destroy.outputs.failedReason }}
    steps:
      - id: validate-destroy
        run: |
          FAILED_REASON="The Request of Destroy Infra Stack is not supported yet."
          echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
          echo "Failed Reason: $FAILED_REASON"
          exit 1

  handle_failure:
    name: Handle Request form Failure
    runs-on: ubuntu-latest
    needs:
      - update_request
      - validate_request
      - diff
      - deployment
      - destroy
    if: failure()
    steps:
      - run: |
          echo 'Update Request: ${{ toJson(needs.update_request) }}'
          echo 'Validate Request: ${{ toJson(needs.validate_request) }}'
          echo 'Diff: ${{ toJson(needs.diff) }}'
          echo 'Deployment: ${{ toJson(needs.deployment) }}'
          echo 'Destroy: ${{ toJson(needs.destroy) }}'
        continue-on-error: true
      - id: prepare-error
        uses: actions/github-script@v7
        env:
          VALIDATION_FAIL_REASON: ${{ needs.update_request.outputs.failed-reason || needs.validate_request.outputs.failed-reason }}
          IS_VALIDATION_FAILED: ${{ needs.update_request.result == 'failure' || needs.validate_request.result == 'failure' || needs.diff.result == 'failure' }}
          DEPLOY_FAILED_REASON: ${{ needs.deployment.outputs.failed-reason }}
          IS_DEPLOY_FAILED: ${{ needs.deployment.result == 'failure' }}
          DESTROY_FAILED_REASON: ${{ needs.destroy.outputs.failed-reason }}
          IS_DESTROY_FAILED: ${{ needs.destroy.result == 'failure' }}
        with:
          script: |
            let errorDetails= "Found unknown error. Please check the logs.";
            if(String(process.env.IS_VALIDATION_FAILED) === "true") {
              errorDetails = process.env.VALIDATION_FAIL_REASON || errorDetails;
              core.setOutput("reason", "Validation of Api Request form is failed.");
              core.setOutput("status", "Denied");
            } else if(String(process.env.IS_DEPLOY_FAILED) === "true") {
              errorDetails = process.env.DEPLOY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Deployment of Infra stack is failed.");
              core.setOutput("status", "Failed");
            } else if(String(process.env.IS_DESTROY_FAILED) === "true") {
              errorDetails = process.env.DESTROY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Destroy of Infra Stack is failed.");
              core.setOutput("status", "Failed");
            } else {
              throw new Error("could not find any fail job");
            }
            core.setOutput("details", errorDetails);
      - name: Add Failed Reason as Comment
        uses: actions/github-script@v7
        env:
          FAIL_REASON: ${{ steps.prepare-error.outputs.reason }}
          ERROR_DETAILS: ${{ steps.prepare-error.outputs.details }}
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
        with:
          script: |
            const commentBody = [
                    "## Request " + process.env.FAIL_STATUS, 
                    "<br/>", "",
                    "### Reason:",
                    "  " + process.env.FAIL_REASON,
                    "", "",
                    "**Error:**  " + process.env.ERROR_DETAILS, 
                    "<br/>",  "",
                    "> [!NOTE]",
                    "> **Needs Action:**   Please raise a `new request form` with correct details. This request issue will be `closed`.",
                    "<br/>", "<br/>",  "",
                    ];
            const workflowTitle = context.workflow +" (" + context.runId + ")";
            const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
            commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

            console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
            const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
            });
            console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
            const commentResponse = github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody.join("\n")
            });
            console.log("commentResponse: ", commentResponse);
      - name: Close Issue
        uses: actions/github-script@v7
        env:
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.update_request.outputs.original-issue-title || github.event.issue.title }}
        with:
          script: |
            const closeUpdateResponse = await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              state: 'closed',
              title: "[" + process.env.FAIL_STATUS + "]" + process.env.ORIGINAL_ISSUE_TITLE,
            });
            console.log("closeUpdateResponse: ", closeUpdateResponse);
            const lockIssueResponse = await github.rest.issues.lock({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number
            });
            console.log("issue is lock again, lock issue response:", lockIssueResponse);
