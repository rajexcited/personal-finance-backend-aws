# This workflow performs basic steps
# build, compile, synth and unit test
name: AWS Infra Deploy

on:
  issues:
    types:
      - opened

concurrency:
  group: ${{ github.workflow }}-${{ github.event.issue.title }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: write
  issues: write
  pull-requests: write

jobs:
  display_output:
    name: Display Output
    runs-on: ubuntu-latest
    steps:
      # https://docs.github.com/en/webhooks/webhook-events-and-payloads#issues
      - run: |
          echo "Issue number: ${{ github.event.issue.number }}"
          echo "Issue id: ${{ github.event.issue.id }}"
      - run: |
          echo "Issue title: ${{ github.event.issue.title }}"
      - run: |
          echo "Issue body: ${{ github.event.issue.body }}"
      - run: |
          echo "Issue milestone title: ${{ github.event.issue.milestone.title }}"
          echo "Issue milestone: ${{ github.event.issue.milestone }}"
      - run: |
          echo "Issue state: ${{ github.event.issue.state }}"
          echo "Issue state reason: ${{ github.event.issue.state_reason }}"
      - run: |
          echo "Issue draft: ${{ github.event.issue.draft }}"
          echo "Issue locked: ${{ github.event.issue.locked }}"
          echo "Issue active lock reason: ${{ github.event.issue.active_lock_reason }}"
      - run: |
          echo "Issue labels name: ${{ toJson(github.event.issue.labels.*.name) }}"
      - run: |
          echo "Issue total comments: ${{ github.event.issue.comments }}"
      - run: |
          echo "Issue updated at: ${{ github.event.issue.updated_at }}"
          echo "Issue closed at: ${{ github.event.issue.closed_at }}"
          echo "Issue created at: ${{ github.event.issue.created_at }}"
      - run: |
          echo "Issue author association: ${{ github.event.issue.author_association }}"
      - run: |
          echo "Issue sender login: ${{ github.event.sender.login }}"
          echo "Issue sender type: ${{ github.event.sender.type }}"
          echo "Issue sender id: ${{ github.event.sender.id }}"
          echo "Issue sender view type: ${{ github.event.sender.user_view_type }}"
      - run: |
          echo "Issue user login: ${{ github.event.issue.user.login }}"
          echo "Issue user type: ${{ github.event.issue.user.type }}"
          echo "Issue user id: ${{ github.event.issue.user.id }}"
          echo "Issue user view type: ${{ github.event.issue.user.user_view_type }}"
      - run: |
          echo "Issue assignee login: ${{ github.event.issue.assignee.login }}"
          echo "Issue assignee type: ${{ github.event.issue.assignee.type }}"
          echo "Issue assignee id: ${{ github.event.issue.assignee.id }}"
          echo "Issue assignee view type: ${{ github.event.issue.assignee.user_view_type }}"
      - run: |
          echo "github actor: ${{ github.actor }}"
          echo "github triggering actor: ${{ github.triggering_actor }}"
          echo "Issue perfomed by app: ${{ github.event.issue.performed_via_github_app }}"
      - run: |
          echo "action: ${{ github.action }}"
          echo "event name: ${{ github.event_name }}"
          echo "event changes: ${{ github.event.changes }}"
          echo "event action: ${{ github.event.action }}"
      - env:
          GITHUB_JSON: ${{ toJson(github) }}
        run: |
          echo github json= $GITHUB_JSON
      - uses: actions/github-script@v7
        with:
          script: |
            console.log("Context obj: ", context);
            console.log("Github Apis: ", github)
            console.log("Github Rest API config: ", github.rest)
            console.log("Github Rest Repo API:", github.rest.git)
            console.log("Github Rest Issues API:", github.rest.issues)

  run_eligible:
    name: Workflow Run Eligible
    runs-on: ubuntu-latest
    outputs:
      original-issue-title: ${{ github.event.issue.title }}
      is-prod-provision: ${{ steps.request-form-issue.outputs.is-prod-provision }}
      is-testplan-provision: ${{ steps.request-form-issue.outputs.is-testplan-provision }}
      is-testplan-deprovision: ${{ steps.request-form-issue.outputs.is-testplan-deprovision }}
      is-prod-rollback: ${{ steps.request-form-issue.outputs.is-prod-rollback }}
      is-testplan: ${{ steps.request-form-issue.outputs.for-testplan }}
      is-production: ${{ steps.request-form-issue.outputs.for-production }}
      env-ref-name: ${{ steps.request-form-issue.outputs.env-ref-name }}
    steps:
      - run: |
          echo "Eligibilities"
          echo "Request form is for deployment purpose"
          echo "Request form must assigned milestone"
          echo "Request form is created by owner"
          echo "Only 1 Environment must exist"
          echo "Request form is either provision or deprovision request"
      - if: >
          ! contains(github.event.issue.labels.*.name, 'deployment') ||
          ! startsWith(github.event.issue.author_association, 'OWNER') ||
          ! github.event.issue.milestone != null
        run: |
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          ! contains(github.event.issue.labels.*.name, 'production') && 
          ! contains(github.event.issue.labels.*.name, 'test plan')
        run: |
          echo "environment label is not defined to issue"
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          contains(github.event.issue.labels.*.name, 'production') && 
          contains(github.event.issue.labels.*.name, 'test plan')
        run: |
          echo "both environment labels are defined to issue"
          echo Workflow is not eligible to process issue
          exit 1
      - if: >
          ! startsWith(github.event.issue.title, '[Request] Provision ') && 
          ! startsWith(github.event.issue.title, '[Request] [Rollback] Provision ') && 
          ! startsWith(github.event.issue.title, '[Request] Deprovision ') 
        run: |
          echo "It is not Request form for provision or deprovision"
          echo Workflow is not eligible to process issue
          exit 1
      - id: request-form-issue
        name: Request Form Issue categorized
        env:
          IS_TESTPLAN: ${{ contains(github.event.issue.labels.*.name, 'test plan') }}
          IS_TESTPLAN_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] Provision Test Plan Environment') }}
          IS_TESTPLAN_DEPROVISION: ${{ startsWith(github.event.issue.title, '[Request] Deprovision Test Plan Environment') }}
          IS_PRODUCTION: ${{ contains(github.event.issue.labels.*.name, 'production') }}
          IS_PRODUCTION_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] Provision Production Environment') }}
          IS_PROD_ROLLBACK_PROVISION: ${{ startsWith(github.event.issue.title, '[Request] [Rollback] Provision Production Environment') }}
        run: |
          if [[ "$IS_TESTPLAN" == "true" ]]; then
            echo "env-ref-name=testplan" >> $GITHUB_OUTPUT
          fi
          if [[ "$IS_PRODUCTION" == "true" ]]; then
            echo "env-ref-name=production" >> $GITHUB_OUTPUT
          fi
          echo "for-testplan=$IS_TESTPLAN" >> $GITHUB_OUTPUT
          echo "for-production=$IS_PRODUCTION" >> $GITHUB_OUTPUT
          echo "is-testplan-provision=$IS_TESTPLAN_PROVISION" >> $GITHUB_OUTPUT
          echo "is-testplan-deprovision=$IS_TESTPLAN_DEPROVISION" >> $GITHUB_OUTPUT
          echo "is-prod-provision=$IS_PRODUCTION_PROVISION" >> $GITHUB_OUTPUT
          echo "is-prod-rollback=$IS_PROD_ROLLBACK_PROVISION" >> $GITHUB_OUTPUT

  update_request:
    name: Start Request
    runs-on: ubuntu-latest
    needs:
      - run_eligible
    outputs:
      failed-reason: ${{ steps.update-request.outputs.failedReason }}
    steps:
      - run: |
          echo "The issue has milestone assigned and locked."
          echo "The issue has required labels (deployment, test plan)."
          echo "This request form is raised by owner."
          echo "This request form title indicates that It is related to provision or deprovision test plan environment."
          echo "We will validate request form issue details."
      - id: update-request
        name: Update Issue - Start Processing
        uses: actions/github-script@v7
        env:
          ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            try {
              const updateResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Processing] " + process.env.ISSUE_TITLE
              });
              console.log("updateResponse: ", updateResponse);
              if(!context.payload.issue.locked) {
                const lockIssueResponse = await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.issue.number
                });
                console.log("Lock issue response:", lockIssueResponse);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  validate_request:
    name: Validate Request Form
    runs-on: ubuntu-latest
    environment:
      name: aws-infra-development
    needs:
      - run_eligible
      - update_request
    outputs:
      branch-name: ${{ steps.get-milestone-testplan.outputs.branch-name || steps.get-milestone-prod.outputs.tagRefName }}
      branch-url: ${{ steps.get-milestone-testplan.outputs.branch-url || steps.get-milestone-prod.outputs.tagRefUrl }}
      failed-reason: ${{ steps.get-milestone-testplan.outputs.failedReason || steps.testplan-issue.outputs.failedReason || steps.testplan-issue2.outputs.failedReason || steps.request-form-testplan.outputs.failedReason || steps.testplan-request-eligible.outputs.failedReason || steps.prod-request-eligible.outputs.failedReason || steps.request-form-prod.outputs.failedReason || steps.get-milestone-prod.outputs.failedReason }}
      testplan-type: ${{ steps.testplan-issue.outputs.testplanType }}
      request-type: ${{ steps.get-request-type.outputs.request-type }}
      testplan-issue-number: ${{ steps.testplan-issue.outputs.testplanIssue-number }}
      testplan-issue-repo: ${{ steps.testplan-issue.outputs.testplanIssue-repo }}
      post-deployment-section: ${{ steps.request-form-prod.outputs.post_deployment_tasks_section }}
      pr-number: ${{ steps.branch-pr.outputs.prNumber }}
      pr-url: ${{ steps.branch-pr.outputs.prUrl }}
    steps:
      - run: |
          echo "if provision, allowed environment is either testplan or production"
          echo "if deprovision, allowed environment is testplan"
          echo "rollback is only for production environment"
          echo "if provision, milestone must be open except case of rollback"
          echo "if production, tag and milestone branch must not exist"
          echo "if rollback, milestone must be closed."
          echo "if rollback, milestone must be immediate good previous version"
          echo "if rollback, tag must exist"
      - id: testplan-request-eligible
        if: needs.run_eligible.outputs.is-testplan == 'true'
        env:
          IS_TESTPLAN_PROVISION: ${{ needs.run_eligible.outputs.is-testplan-provision }}
          IS_TESTPLAN_DEPROVISION: ${{ needs.run_eligible.outputs.is-testplan-deprovision }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          # validation relaxed for milestone if deprovision
          if [[ "$IS_TESTPLAN_DEPROVISION" == "true" ]]; then
            ELIGIBLE="true"
          elif [[ "$IS_TESTPLAN_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, testplan provision or deprovision request. But found values, testpln provision? $IS_TESTPLAN_PROVISION, testplan deprovision? $IS_TESTPLAN_DEPROVISION"
            echo "Criteria-2, testplan environment."
            echo "Criteria-3, open milestone. But found values, milestone open? $IS_MILESTONE_OPEN"
            echo "failedReason=for testplan request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: prod-request-eligible
        if: needs.run_eligible.outputs.is-production == 'true'
        env:
          IS_PRODUCTION_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_PROD_ROLLBACK_PROVISION: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_MILESTONE_OPEN: ${{ github.event.issue.milestone.state == 'open' }}
        run: |
          ELIGIBLE="false"
          if [[ "$IS_PRODUCTION_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "true" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$IS_PROD_ROLLBACK_PROVISION" == "true" && "$IS_MILESTONE_OPEN" == "false" ]]; then
            ELIGIBLE="true"
          fi
          if [[ "$ELIGIBLE" == "false" ]]; then
            echo "failed request form criteria"
            echo "Criteria-1, production or rollback provision request. But found values, prod provision? $IS_PRODUCTION_PROVISION, prod rollback provision? $IS_PROD_ROLLBACK_PROVISION"
            echo "Criteria-2, production environment."
            echo "Criteria-3, open milestone if production, closed milestone if rollback. But found values, milestone open? $IS_MILESTONE_OPEN"
            echo "failedReason=for prod request form, milestone or label assignments are incorrect" >> $GITHUB_OUTPUT
            exit 1
          fi
      - id: get-request-type
        env:
          IS_TESTPLAN_DEPROVISION: ${{ needs.run_eligible.outputs.is-testplan-deprovision }}
        run: |
          # since provision and deprovision conditions are verified appropriate to env, here we don't need to have repeatated conditions
          if [[ "$IS_TESTPLAN_DEPROVISION" == "true" ]]; then
            echo "request-type=deprovision" >> $GITHUB_OUTPUT
          else
            echo "request-type=provision" >> $GITHUB_OUTPUT
          fi
      - name: Checkout
        uses: actions/checkout@v4
      - id: get-milestone-testplan
        name: Validate Milestone and Branch
        # validation relaxed for milestone if deprovision
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        env:
          TESTPLAN_REQUEST_TYPE: ${{ steps.get-request-type.outputs.request-type }}
        with:
          script: |
            try {
              // verify milestone branch exists
              console.log("issue has milestone title: ", context.payload.issue.milestone.title);
              // if milestone is open, there should be branch with milestone title
              const branchDetails = { name: "", url: "" };
              if(context.payload.issue.milestone.state === "open") {
                if(!context.payload.issue.milestone.due_on) {
                  throw new Error("Milestone due date is not set");
                }
                const milestoneDueOn = new Date(context.payload.issue.milestone.due_on);
                if(milestoneDueOn < new Date()) {
                  throw new Error("Milestone due date is already passed");
                }
                const milestoneBranch = `milestone/${context.payload.issue.milestone.title}`;
                try {
                  const getBranchResponse = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: milestoneBranch
                  });
                  console.log("getBranchResponse: ", getBranchResponse);
                  branchDetails.name=getBranchResponse.data.name;
                  branchDetails.url=getBranchResponse.data._links.html;
                } catch(e) {
                  // rethrow error and fail the step execution if provisioning request
                  if(process.env.TESTPLAN_REQUEST_TYPE === "provision") {
                    throw e;
                  }
                }
                // compare branch only if provisioning request
                if(process.env.TESTPLAN_REQUEST_TYPE === "provision") {
                  // verify milestone branch commit has merged all of the master branch
                  const compareResponse = await github.rest.repos.compareCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    base: "master",
                    head: milestoneBranch
                  });
                  console.log("milestone branch as head and master branch as base, compareResponse: ", compareResponse);
                  if (compareResponse.data.behind_by > 0) {
                    throw new Error(`Milestone branch [${milestoneBranch}] is behind master by ${compareResponse.data.behind_by} commits.`);
                  }
                }
              }
              if((process.env.TESTPLAN_REQUEST_TYPE === "provision" && context.payload.issue.milestone.state !== "open") || (process.env.TESTPLAN_REQUEST_TYPE === "deprovision" && !branchDetails.name)) {
                // if milestone is closed, the master branch should have milestone version
                // for deprovisioning, if milestone is open, the master branch should have milestone version;
                // compare package.json and milestone version
                const fs = require('fs');
                const packageJson = fs.readFileSync('package.json', 'utf8');
                const packageJsonObj = JSON.parse(packageJson);
                if(`v${packageJsonObj.version}` !== context.payload.issue.milestone.title) {
                  throw new Error(`Master branch package.json version [${packageJsonObj.version}] does not match with requested milestone version [${context.payload.issue.milestone.title}]`);
                }
                const getBranchResponse = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: "master"
                });
                branchDetails.name=getBranchResponse.data.name;
                branchDetails.url=getBranchResponse.data._links.html;
              }
              core.setOutput("branch", branchDetails); 
              core.setOutput("branch-name", branchDetails.name); 
              core.setOutput("branch-url", branchDetails.url);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: testplan-issue
        name: Validate Testplan issue
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        env:
          TESTPLAN_REQUEST_TYPE: ${{ steps.get-request-type.outputs.request-type }}
        with:
          script: |
            try {
              // verify if regression label exists ? if so, set as output for further use
              // currently only regression type testplan is allowed.
              const allowedTestplanTypes = ["regression"];
              const foundTypeLabel = context.payload.issue.labels.find(label=>allowedTestplanTypes.includes(label.name));
              core.setOutput("testplanType", foundTypeLabel?.name || "unknown");
              if(!foundTypeLabel) {
                throw new Error("Test plan type label not found in issue labels");
              }
              // find test plan issue with same milestone and type label
              const testplanIssueRegex = new RegExp(".+"+foundTypeLabel.name+" Test Plan:.+https://github.com/"+context.repo.owner+"/([^/]+)/issues/(\\d+).+", "i");
              if(!testplanIssueRegex.test(context.payload.issue.body)) {
                throw new Error("Test plan issue link not found")
              }
              const matchedGroups = testplanIssueRegex.exec(context.payload.issue.body);
              // console.log("found match groups: ", matchedGroups);
              const testplanIssueRepo = matchedGroups[1];
              const testplanIssueNumber = matchedGroups[2];
              if(!testplanIssueNumber || !testplanIssueRepo) {
                // this is unlikely, only in case of ambiguous request form 
                throw new Error("Test plan issue link is not properly formatted.");
              }
              const allowedLabels = [foundTypeLabel.name, "test plan"];
              if(testplanIssueRepo === context.repo.repo) {
                const getIssueResponse = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: testplanIssueRepo,
                  issue_number: testplanIssueNumber
                });
                console.log("getIssueResponse: ", getIssueResponse);
                const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
                if(testplanLabels.length!==allowedLabels.length){
                  throw new Error("missing required labels in given testplan issue");
                }
                if(getIssueResponse.data.milestone.number!==context.payload.issue.milestone.number){
                  throw new Error("assigned milestone to given testplan issue is not same with this issue");
                }
                // validation relaxed - testplan issue can be open or closed for deprovisioning
                if(process.env.TESTPLAN_REQUEST_TYPE === "provision" && getIssueResponse.data.state!=="open"){
                  throw new Error("testplan issue not open");
                }
              }
              const testplanDetails = {
                  number: testplanIssueNumber,
                  repo: testplanIssueRepo,
                  allowedLabels: allowedLabels
              };
              core.setOutput("testplanIssue", testplanDetails);
              core.setOutput("testplanIssue-number", testplanDetails.number);
              core.setOutput("testplanIssue-repo", testplanDetails.repo);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: testplan-issue2
        name: Validate testplan issue from another repo
        if: needs.run_eligible.outputs.is-testplan == 'true'
        uses: actions/github-script@v7
        env:
          TESTPLAN_REQUEST_TYPE: ${{ steps.get-request-type.outputs.request-type }}
        with:
          github-token: ${{ secrets.REPO_AWS_PAT }}
          script: |
            try {
              const testPlanIssueDetails = ${{ steps.testplan-issue.outputs.testplanIssue }};
              if(testPlanIssueDetails.repo === context.repo.repo) {
                console.log("already verified");
                return;
              }
              const getIssueResponse = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: testPlanIssueDetails.repo,
                issue_number: testPlanIssueDetails.number
              });
              console.log("getIssueResponse: ", getIssueResponse);
              const allowedLabels = testPlanIssueDetails.allowedLabels;
              const testplanLabels = getIssueResponse.data.labels.filter(label=>allowedLabels.includes(label.name));
              if(testplanLabels.length!==allowedLabels.length){
                throw new Error("missing required labels in given testplan issue");
              }
              // validation relaxed - testplan issue can be open or closed for deprovisioning
              if(process.env.TESTPLAN_REQUEST_TYPE === "provision" && getIssueResponse.data.state!=="open"){
                throw new Error("testplan issue not open");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during test plan validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: get-milestone-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Milestone and Branch
        uses: actions/github-script@v7
        env:
          IS_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const getBranch = async (branchName, tagName) => {
                try {
                  if(branchName) {
                    const getBranchResponse = await github.rest.repos.getBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      branch: branchName
                    });
                    console.log("getBranchResponse: ", getBranchResponse);
                    return getBranchResponse.data;
                  }
                  if(tagName) {
                    const getRefResponse = await github.rest.git.getRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `tags/${tagName}`
                    });
                    console.log("getRefResponse: ", getRefResponse);
                    return getRefResponse.data;
                  }
                  throw new Error("requested neither branch nor tag");
                } catch(e) {
                  console.error("error during getBranch rest call", e);
                }
                return null;
              };
              // milestone due Date must be configured and is not past.
              if(!context.payload.issue.milestone.due_on) {
                throw new Error("Milestone due date is not set");
              }
              if(process.env.IS_ROLLBACK != "true") {
                // for prod deployment, date has to be today
                const milestoneDueOnDate = toTime(context.payload.issue.milestone.due_on).substring(0,10);
                if(milestoneDueOnDate !== toTime(new Date()).substring(0,10)) {
                  throw new Error("Milestone due date is not today");
                }
              }
              // verify milestone branch not exists
              const milestoneBranch = await getBranch(`milestone/${context.payload.issue.milestone.title}`);
              if(milestoneBranch) {
                throw new Error("milestone branch exist. It has to be merge to master and delete before prod deployment");
              }
              // verify tag ref
              const tagRef = await getBranch(null, context.payload.issue.milestone.title);
              if(tagRef && process.env.IS_ROLLBACK != "true") {
                throw new Error(`for production deploy, tag [${context.payload.issue.milestone.title}] cannot exist.`);
              }
              if(!tagRef && process.env.IS_ROLLBACK == "true") {
                throw new Error(`for production rollback deploy, tag [${context.payload.issue.milestone.title}] not found.`);
              }
              core.setOutput("tagRefName", tagRef?.name);
              core.setOutput("tagRefUrl", tagRef?._links.html);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          cache: "pip" # caching pip dependencies
          python-version: "3.13"
      - id: request-issue
        uses: actions/github-script@v7
        with:
          script: |
            core.setOutput("issueDetails", context.payload.issue);
      - id: request-form-testplan
        if: needs.run_eligible.outputs.is-testplan == 'true'
        name: Validate Request form details
        env:
          TESTPLAN_TYPE: ${{ steps.testplan-issue.outputs.testplanType }}
          TESTPLAN_REQUEST_TYPE: ${{ steps.get-request-type.outputs.request-type }}
          ISSUE_DETAILS: ${{ steps.request-issue.outputs.issueDetails }}
          BRANCH_DETAILS: ${{ steps.get-milestone-testplan.outputs.branch }}
        run: |
          cd .github
          echo $ISSUE_DETAILS > request_form_issue_details.json
          echo $BRANCH_DETAILS > branch_details.json
          python --version
          pip install -r scripts/requirements.txt
          # capture error code +-e
          set +e
          python -m scripts.request.deploy.testplan --validate \
              --request-form-issue-details "request_form_issue_details.json" \
              --testplan-type "$TESTPLAN_TYPE" --request-type $TESTPLAN_REQUEST_TYPE \
              --branch-details "branch_details.json" > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - id: request-form-prod
        if: needs.run_eligible.outputs.is-production == 'true'
        name: Validate Request Form Details
        env:
          ISSUE_DETAILS: ${{ steps.request-issue.outputs.issueDetails }}
        run: |
          cd .github
          echo $ISSUE_DETAILS > request_form_issue_details.json
          python --version
          pip install -r scripts/requirements.txt
          set +e
          python -m scripts.request.deploy.production --validate \
              --request-form-issue-details "request_form_issue_details.json"  > deploy_request_output.log 2>&1
          RETURN_CODE=$?
          set -e
          if [ $RETURN_CODE -ne 0 ]; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            cat deploy_request_output.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi
          cat deploy_request_output.log
          exit $RETURN_CODE
      - name: Validate Rollback
        if: needs.run_eligible.outputs.is-prod-rollback == 'true'
        uses: actions/github-script@v7
        env:
          EXISTING_VERSION: ${{ steps.request-form-prod.outputs.existing_version }}
        with:
          script: |
            try {
              // tag is already verified
              // here, verify rollback milestone is closed
              // verify released approved issue exists
              // relaxed other validations
              const listMilestonesResponse = await github.rest.issues.listMilestones({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: "closed"
              });
              console.log("listMilestonesResponse: ", listMilestonesResponse);
              // here, verify rollback milestone is closed
              const deployedMilestone=listMilestonesResponse.data.find(mlst=>mlst.title===process.env.EXISTING_VERSION);
              if(!deployedMilestone) {
                throw new Error("deployed milestone is not found");
              }
              // verify approved prod release issue exists
              const listIssuesResponse = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ["deployment", "production"],
                state: "closed",
                milestone: deployedMilestone.number
              });
              console.log("listIssuesResponse: ", listIssuesResponse);
              const releasedRequest = listIssuesResponse.data.find(iss=>iss.title.startsWith("[Approved] [Request] Provision Production Environment"));
              if(!releasedRequest) {
                throw new Error("prod release request form not found");
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during rollback validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: branch-pr
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: ${{ steps.get-milestone-testplan.outputs.branch-name }}
        with:
          script: |
            try {
              if(!process.env.BRANCH_NAME.startsWith("milestone/")) {
                return;
              }
              const openPRListResponse = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: "master",
                head: process.env.BRANCH_NAME
              });
              console.log("openPRListResponse: ", openPRListResponse);
              const foundPr = openPRListResponse.data.find(pr=>pr.milestone.number===context.payload.issue.milestone.number)
              core.setOutput("prNumber", foundPr?.number);
              core.setOutput("prUrl", foundPr?.html_url);
            } catch(ignore) {
            }

  validate_request_stack:
    name: Validate Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
    outputs:
      failed-reason: ${{ steps.provision-stack-testplan.outputs.failedReason || steps.deprovision-stack-testplan.outputs.failedReason || steps.provision-stack-prod.outputs.failedReason || steps.provision-stack-prod-rollback.outputs.failedReason }}
      stack-details: ${{ steps.provision-stack-testplan.outputs.stack_details || steps.deprovision-stack-testplan.outputs.stack_details || steps.provision-stack-prod.outputs.stack_details || steps.provision-stack-prod-rollback.outputs.stack_details || '{}' }}
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: provision-stack-prod
        name: Verify branch is deployable
        # release or rollback
        if: needs.run_eligible.outputs.is-prod-provision == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ ! "$STACK_STATUS" =~ _COMPLETE$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is not complete, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "$STACK_AUDIT"
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: provision-stack-prod-rollback
        name: Verify Rollback Stack
        # release or rollback
        if: needs.run_eligible.outputs.is-prod-rollback == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
          ROLLBACK_MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Infra Stack does not exist. Rollback is not possible"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit $RET_CODE
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is in progress, $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check milestone 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" == "$ROLLBACK_MILESTONE_TITLE" ]]; then
            FAILED_REASON="There was already rollback deployment attempt. Another attempt is not possible"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "$STACK_AUDIT"
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: provision-stack-testplan
        name: Verify branch is deployable
        if: needs.run_eligible.outputs.is-testplan-provision == 'true'
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISS_REPO: ${{ needs.validate_request.outputs.testplan-issue-repo }}
          TESTPLAN_ISS_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          REQUEST_ISS_REPO: ${{ github.event.repository.name }}
          REQUEST_ISS_NUMBER: ${{ github.event.issue.number }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          # replacing status check. previously was _COMPLETE, but if status is failed, allow to redeploy
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack status is in progress, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check milestone 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Type 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanType").Value')
          if [[ "$TAG_VALUE" != "$TESTPLAN_TYPE" ]]; then
            FAILED_REASON="The testplan type doesnot match. Found $TAG_VALUE testplan type."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check testplan Issue number 
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanIssueNumber").Value')
          EXPECTED_TESTPLAN_ISS="$TESTPLAN_ISS_REPO/issue-$TESTPLAN_ISS_NUMBER"
          if [[ "$TAG_VALUE" != "$EXPECTED_TESTPLAN_ISS" ]]; then
            FAILED_REASON="The stack is deployed for another testplan issue, $TAG_VALUE, instead of $EXPECTED_TESTPLAN_ISS."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # check request Issue number, make sure request is not duplicate
          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="requestIssueNumber").Value')
          EXPECTED_REQUEST_ISS="$REQUEST_ISS_REPO/issue-$REQUEST_ISS_NUMBER"
          if [[ "$TAG_VALUE" == "$EXPECTED_REQUEST_ISS" ]]; then
            FAILED_REASON="The stack deployment is attempted with provided request form. Can not re-use same request form."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'

          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: deprovision-stack-testplan
        if: needs.run_eligible.outputs.is-testplan-deprovision == 'true'
        name: Verify branch is destroyable
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.issue.milestone.title }}
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
        run: |
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"  
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Infra Stack does not exist. given branch for milestone has already been destroyed."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
          if [[ "$TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
            FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          TAG_VALUE=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="testplanType").Value')
          if [[ "$TAG_VALUE" != "$TESTPLAN_TYPE" ]]; then
            FAILED_REASON="The testplan type is not matching with deployed stack. The stack is deployed for $TAG_VALUE testplan type, but expected $TESTPLAN_TYPE."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ "$STACK_STATUS" =~ _IN_PROGRESS$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The Stack is still in progress with Status: $STACK_STATUS. And Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          STACK_AUDIT='{"api":'$API_STACK_AUDIT'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  create_tag:
    name: Create Tag
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_request_stack
    outputs:
      failed-reason: ${{ steps.no-branch.outputs.failedReason || steps.create-prod-tag.outputs.failedReason }}
      branch-tag-name: ${{ needs.validate_request.outputs.branch-name || github.event.issue.milestone.title }}
    if: needs.validate_request.outputs.request-type == 'provision'
    steps:
      - id: no-branch
        env:
          BRANCH_NAME: ${{ needs.validate_request.outputs.branch-name }}
          IS_PROD_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          IS_PROD_PROVISION: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
        run: |
          if [[ -z "$BRANCH_NAME" ]]; then
            if [[ "$IS_PROD_ROLLBACK" == "true" ]]; then
              FAILED_REASON="Tag for prod rollback is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
            if [[ "$IS_TESTPLAN" == "true" ]]; then
              FAILED_REASON="Milestone Branch is not defined."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "$FAILED_REASON"
              exit 1
            fi
          elif [[ "$IS_PROD_PROVISION" == "true" ]]; then
            FAILED_REASON="Tag cannot be available for prod."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "$FAILED_REASON"
            exit 1
          fi
      - name: Checkout
        uses: actions/checkout@v4
      - id: create-prod-tag
        name: Create Tag
        if: needs.run_eligible.outputs.is-prod-provision == 'true'
        env:
          TAG_VER: ${{ github.event.issue.milestone.title }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          LOG_FILE="create_tag.failed.log"
          if ! git tag -a "$TAG_VER" -m "Release $TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to create tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi
          if ! git push origin "$TAG_VER" 2>>"$LOG_FILE"; then
            echo "failedReason<<EOF" >> $GITHUB_OUTPUT
            echo "Failed to push tag $TAG_VER." >> $GITHUB_OUTPUT
            echo "$(cat $LOG_FILE)" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 1
          fi

  diff:
    name: Infra Stack Diff
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - create_tag
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      stack-tags: ${{ steps.prepare-tags.outputs.stackTags }}
    steps:
      - name: Display Needs
        run: |
          echo "Needs of Validate Request: ${{ toJson(needs.validate_request) }}"
          echo "Needs of Update Request: ${{ toJson(needs.update_request) }}"
          echo "Milestone branch name: ${{ needs.validate_request.outputs.branch-name }}"
          echo "Testplan Type: ${{ needs.validate_request.outputs.testplan-type }}"
          echo "Testplan Issue Number: ${{ needs.validate_request.outputs.testplan-issue-number }}"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create_tag.outputs.branch-tag-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          pwd
          mkdir -p dist/ui
          echo ls -lrt
          ls -lrt
          echo ls -lrt dist
          ls -lrt dist
          echo ls -lrt ../
          ls -lrt ../
      - id: prepare-tags
        uses: actions/github-script@v7
        env:
          TESTPLAN_TYPE: ${{ needs.validate_request.outputs.testplan-type }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          TESTPLAN_ISSUE_REPO: ${{ needs.validate_request.outputs.testplan-issue-repo }}
        with:
          script: |
            const stackTags = [];
            stackTags.push(`workflow_run_id=${context.runId}`);
            stackTags.push(`milestone=${context.payload.issue.milestone.title}`);
            if(process.env.TESTPLAN_TYPE && process.env.TESTPLAN_ISSUE_REPO && process.env.TESTPLAN_ISSUE_NUMBER) {
              stackTags.push(`testplanType=${process.env.TESTPLAN_TYPE}`);
              stackTags.push(`testplanIssueNumber=${process.env.TESTPLAN_ISSUE_REPO}/issue-${process.env.TESTPLAN_ISSUE_NUMBER}`);
            }
            stackTags.push(`requestIssueNumber=${context.repo.repo}/issue-${context.payload.issue.number}`);
            core.setOutput("stackTags", stackTags);
      - run: |
          echo "Infra Stack TAGS: ${{ toJson(steps.prepare-tags.outputs.stackTags) }}"
          echo "Infra Stack TAGS: ${{ join(steps.prepare-tags.outputs.stackTags) }}"
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: cdk diff
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "diff"
          actions_comment: false
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ join(steps.prepare-tags.outputs.stackTags) }}

  deployment:
    name: Deploy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - diff
      - create_tag
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.deploying-comment.outputs.failedReason || steps.describe-stack.outputs.failedReason || steps.update-issue-deploy-complete.outputs.failedReason || steps.post-deployment-verification-issue.outputs.failedReason }}
    steps:
      - name: Display Needs
        run: |
          echo "Needs of Validate Request: ${{ toJson(needs.validate_request.outputs) }}"
          echo "Needs of Update Request: ${{ toJson(needs.update_request.outputs) }}"
          echo "Needs of Diff: ${{ toJson(needs.diff.outputs) }}"
          echo "Needs of Validate Request Stack: ${{ toJson(needs.validate_request_stack.outputs) }}"
          echo "from validate request, Milestone branch name: ${{ needs.validate_request.outputs.branch-name }}"
          echo "from validate request, Testplan Type: ${{ needs.validate_request.outputs.testplan-type }}"
          echo "from update request, Original Issue Title: ${{ needs.update_request.outputs.original-issue-title }}"
          echo "from validate request, Stack Details: ${{ needs.validate_request.outputs.stack-details }}"
          echo "from validate request, Stack Details: ${{ toJson(needs.validate_request.outputs.stack-details) }}"
          echo "from diff, Stack Tags: ${{ join(needs.diff.outputs.stack-tags) }}"
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create_tag.outputs.branch-tag-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm --version
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          jq "del(.devDependencies, .scripts, .bin)" package.json > dist/lambda_layer/nodejs/package.json
          cd dist/lambda_layer/nodejs
          npm install .
          cd ../../..
          mkdir -p dist/ui
          pwd
          echo ls -lrt
          ls -lrt
          echo ls -lrt dist
          ls -lrt dist
          echo ls -lrt dist/ui
          ls -lrt dist/ui
          echo ls -lrt ../
          ls -lrt ../
      - id: deploying-comment
        name: Update Issue - Deploying
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.create_tag.outputs.branch-tag-name }}
          IS_FOR_TESTPLAN: ${{ needs.run_eligible.outputs.is-testplan }}
          IS_PROD_RELEASE: ${{ needs.run_eligible.outputs.is-prod-provision }}
          IS_PROD_ROLLBACK: ${{ needs.run_eligible.outputs.is-prod-rollback }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
          PR_LINK: ${{ needs.validate_request.outputs.pr-url }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const deploymentStartTime = new Date().toISOString();
              core.setOutput("deploymentStartTime", deploymentStartTime);
              let prodType="";
              if(process.env.IS_PROD_RELEASE == "true") {
                prodType="Release "
              }
              if(process.env.IS_PROD_ROLLBACK == "true") {
                prodType="Rollback "
              }
              const commentBody = [
                `## Infra ${prodType}Deployment Started`,
                "", "### Start Time: ", "",
                "  " + toTime(deploymentStartTime)
              ];
              if("true" == process.env.IS_FOR_TESTPLAN) {
                commentBody.push("", "### Milestone Branch: ", "");
              } else {
                commentBody.push("", "### Tag: ", "");
              }
              commentBody.push("  " + process.env.MILESTONE_BRANCH_NAME);

              const stackDetails = ${{ needs.validate_request_stack.outputs.stack-details }};
              commentBody.push("", "### API Stack: ", "");
              
              if(stackDetails.api) {
                // audit details available
                commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
                commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              } else {
                commentBody.push("API Stack is not found. It seems to be first deployment.");
              }
              if(process.env.PR_NUMBER && process.env.PR_LINK) {
                commentBody.push("", "### Open PR" ,"");
                commentBody.push(`- [PR - ${process.env.PR_NUMBER}](${process.env.PR_LINK})`);
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the deployment to complete. This issue will be updated with deployment status.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              // console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment start comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: cdk-deploy
        name: cdk deploy
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "deploy"
          cdk_stack: "MyFinanceInfraStack"
          debug_log: true
          actions_comment: false
          cdk_args: "--require-approval never --exclusively"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ needs.diff.outputs.stack-tags }}
        continue-on-error: true
      - id: describe-stack
        name: Describe stack
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          CDK_DEPLOY_OUTCOME: ${{ steps.cdk-deploy.outcome }}
        run: |
          echo "cdk deploy outcome: $CDK_DEPLOY_OUTCOME"
          INFRA_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$INFRA_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            FAILED_REASON="Failed to describe stack. Error: $DESCRIBE_STACK_OUT"
            echo "failedReason=$FAILED_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            exit $RET_CODE
          fi
          if [ "$CDK_DEPLOY_OUTCOME" == "failure" ]; then
            STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="CDK deployment failed. please check logs for details. Stack Status is $STACK_STATUS and Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            exit 1
          fi

          API_CREATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].CreationTime")
          API_UPDATED_TIME=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].LastUpdatedTime")
          API_STACK_AUDIT='{"created_time":"'$API_CREATED_TIME'","updated_time":"'$API_UPDATED_TIME'"}'
          STACK_OUTPUTS=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Outputs")
          STACK_TAGS=$(echo "$DESCRIBE_STACK_OUT" | jq -r ".Stacks[0].Tags")
          STACK_AUDIT='{"api":'$API_STACK_AUDIT',"outputs":'$STACK_OUTPUTS',"tags":'$STACK_TAGS'}'
          echo "stack_details<<EOF" >> $GITHUB_OUTPUT
          echo "$STACK_AUDIT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - id: update-issue-deploy-complete
        name: Update Issue - Deployment Complete
        uses: actions/github-script@v7
        env:
          DEPLOYMENT_START_TIME: ${{ steps.deploying-comment.outputs.deploymentStartTime }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
        with:
          script: |
            try {
              console.log("Deployment Start Time: ", process.env.DEPLOYMENT_START_TIME);
              const stackDetails = ${{ steps.describe-stack.outputs.stack_details }};
              console.log("Stack Details: ", stackDetails);
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const deploymentEndTime = new Date();
              const diffParts = new Date(deploymentEndTime - new Date(process.env.DEPLOYMENT_START_TIME)).toISOString().substr(11, 8).split(":");
              const getNonZero = (value, suffix) => {
                const pluralS = value>1? "s" : "";
                if(value>0) { 
                  return `${value} ${suffix}${pluralS}`; 
                }
                return "";
              };
              let duration = "";
              duration += getNonZero(parseInt(diffParts[0]), "hour") + " ";
              duration += getNonZero(parseInt(diffParts[1]), "minute") + " ";
              duration += getNonZero(parseInt(diffParts[2]), "second") + " ";
              
              const commentBody = [
                "## Infra Deployment Completed",
                "<br/>", 
                "", "### Deployment Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${toTime(process.env.DEPLOYMENT_START_TIME)} |`,
                `| **End Time** | ${toTime(deploymentEndTime.toISOString())} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];
              
              commentBody.push("", "### Stack Outputs: ", "");
              stackDetails.outputs.forEach(output => {
                if(output.OutputKey.startsWith("DistributionDomain")) {
                  commentBody.push(` - **${output.OutputKey}:** https://${output.OutputValue}  `);
                } else {
                  commentBody.push(` - **${output.OutputKey}:** ${output.OutputValue}  `);
                }
              });
              if(stackDetails.outputs.length === 0) {
                commentBody.push("  No outputs found.  ");
              }
              
              commentBody.push("", "### Stack Tags: ", "");
              stackDetails.tags.forEach(tag => {
                commentBody.push(` - **${tag.Key}:** ${tag.Value}  `);
              });

              commentBody.push("", "### Stack Audit: ", "");
              // audit details available
              commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
              commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));
              
              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The deployment is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              // console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
              if(process.env.PR_NUMBER) {
                const prCommentResponse = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: commentBody.join("\n")
                });
                console.log("for PR, commentResponse: ", prCommentResponse);
              }
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during deployment complete comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - id: post-deployment-verification-issue
        name: Post Deployment Verification Issue
        uses: actions/github-script@v7
        if: needs.run_eligible.outputs.is-production == 'true'
        env:
          POST_DEPLOY_REQ_SECTION: ${{ needs.validate_request.outputs.post-deployment-section }}
          IS_RELEASE: ${{ needs.run_eligible.outputs.is-prod-provision }}
        with:
          script: |
            try {
              let deploymentType = "Release";
              if(process.env.IS_RELEASE != "true") {
                deploymentType = "Rollback";
              }
              let issueBody = `\n## ${deploymentType} Deployment Completed\n\n`;
              issueBody += `- Parent Request [Issue-${context.payload.issue.number}](${context.payload.issue.html_url})\n\n`;
              issueBody += process.env.POST_DEPLOY_REQ_SECTION;
              issueBody += "\n\n  ";
              issueBody += "> [!IMPORTANT]  \n";
              issueBody += "> Please checked tasks if verified successfully. When post deployment verification is completed, close the issue regardless the status to mark the deployment attempt complete.  ";
              const createIssueResponse = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: "[Task] Post Deployment Verifications for Prod " + deploymentType,
                body: issueBody,
                labels: context.payload.issue.labels.map(label=>label.name),
                milestone: context.payload.issue.milestone.number
              });
              console.log("api createIssueResponse: ", createIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: createIssueResponse.data.number
              });
              console.log("lock issue response:", lockIssueResponse);
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update for deployment completion, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  destroy:
    name: Destroy Infra Stack
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - validate_request
      - validate_request_stack
    if: needs.run_eligible.outputs.is-testplan-deprovision == 'true'
    environment:
      name: aws-infra-${{ needs.run_eligible.outputs.env-ref-name }}
    outputs:
      failed-reason: ${{ steps.destroying-comment.outputs.failedReason || steps.describe-stack.outputs.failedReason || steps.update-issue-destroy-complete.outputs.failedReason || steps.empty-bucket.outputs.failedReason }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_request.outputs.branch-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - name: Prepare for Lambda Layer Asset
        run: |
          npm --version
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          mkdir -p dist/ui
          pwd
      - id: destroying-comment
        name: Update Issue - Deploying
        uses: actions/github-script@v7
        env:
          MILESTONE_BRANCH_NAME: ${{ needs.validate_request.outputs.branch-name }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
          PR_LINK: ${{ needs.validate_request.outputs.pr-url }}
        with:
          script: |
            try {
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const destroyStartTime = new Date().toISOString();
              core.setOutput("destroyStartTime", destroyStartTime);
              const commentBody = [
                "## Infra Stack Destroy Started",
                "", "### Start Time: ", "",
                "  " + toTime(destroyStartTime)
              ];
              if(process.env.MILESTONE_BRANCH_NAME.startsWith("milestone/")) {
                commentBody.push("", "### Milestone Branch: ", "");
                commentBody.push("  " + process.env.MILESTONE_BRANCH_NAME);
              }

              const stackDetails = ${{ needs.validate_request_stack.outputs.stack-details }};
              commentBody.push("", "### API Stack: ", "");
              // audit details available
              commentBody.push("- **Created On:**  " + toTime(stackDetails.api.created_time));
              commentBody.push("- **Updated On:**  " + toTime(stackDetails.api.updated_time));

              if(process.env.PR_NUMBER && process.env.PR_LINK) {
                commentBody.push("", "### Open PR" ,"");
                commentBody.push(`- [PR - ${process.env.PR_NUMBER}](${process.env.PR_LINK})`);
              }

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> Please wait for the destroy to complete. This issue will be updated with destroy status.");
              commentBody.push("<br/>", "<br/>",  "");

              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              const commentResponse = github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                title: "[Approved] " + process.env.ORIGINAL_ISSUE_TITLE
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during destroy start comment, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: empty-bucket
        name: Empty S3 bucket
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
        run: |
          RECEIPT_S3_BUCKET="prsfin-$INFRA_ENV-expense-receipt-s3-bucket"
          echo "deleting all objects from s3 bucket [$RECEIPT_S3_BUCKET] before destroying stack"
          set +e
          EMPTY_BUCKET_OUT=$(aws s3 rm s3://$RECEIPT_S3_BUCKET --recursive --only-show-errors)
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 || -n $EMPTY_BUCKET_OUT ]]; then
            FAILED_REASON="There was error emptying bucket. Error: $EMPTY_BUCKET_OUT"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "failedReason=$FAILED_REASON"
            exit 1
          fi
      - name: cdk destroy
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "destroy"
          debug_log: true
          actions_comment: false
          cdk_args: "--force"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ""
        continue-on-error: true
      - id: describe-stack
        name: Describe stack
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
        run: |
          STACK_NAME="prsfin-$INFRA_ENV-ui-deploy-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -eq 0 ]]; then
            STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            echo "failedReason=UI Stack has not be destroyed. Stack Staus: $STACK_STATUS. and reason: $STACK_STATUS_REASON" >> $GITHUB_OUTPUT
            exit 1
          fi

          STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          set +e
          DESCRIBE_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -eq 0 ]]; then
            STACK_STATUS=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            STACK_STATUS_REASON=$(echo "$DESCRIBE_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            echo "failedReason=Infra Stack has not be destroyed. Stack Staus: $STACK_STATUS. and reason: $STACK_STATUS_REASON" >> $GITHUB_OUTPUT
            exit 1
          fi
      - id: update-issue-destroy-complete
        name: Update Issue - Destroy Complete
        uses: actions/github-script@v7
        env:
          DESTROY_START_TIME: ${{ steps.destroying-comment.outputs.destroyStartTime }}
          TESTPLAN_ISSUE_NUMBER: ${{ needs.validate_request.outputs.testplan-issue-number }}
          PR_NUMBER: ${{ needs.validate_request.outputs.pr-number }}
        with:
          script: |
            try {
              const destroyEndTime = new Date();
              // Convert UTC to Central Time
              const centralTimeFormat = new Intl.DateTimeFormat("en-US", {
                timeZone: "America/Chicago", 
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                timeZoneName: "short"
              });
              const toTime = (datetime) => {
                const date = new Date(datetime);
                if(date.toString() === "Invalid Date") {
                  return "NA";
                }
                return centralTimeFormat.format(date);
              };
              const diffParts = new Date(destroyEndTime - new Date(process.env.DESTROY_START_TIME)).toISOString().substr(11, 8).split(":");
              const getNonZero = (value, suffix) => {
                const pluralS = value>1? "s" : "";
                if(value>0) { 
                  return `${value} ${suffix}${pluralS}`; 
                }
                return "";
              };
              let duration = "";
              duration += getNonZero(parseInt(diffParts[0]), "hour") + " ";
              duration += getNonZero(parseInt(diffParts[1]), "minute") + " ";
              duration += getNonZero(parseInt(diffParts[2]), "second") + " ";
              const commentBody = [
                "## Stack Destroy Completed",
                "<br/>", 
                "", "### Destroy Time: ", "",
                "| | time |", 
                "|---|---|",
                `| **Start Time** | ${toTime(process.env.DESTROY_START_TIME)} |`,
                `| **End Time** | ${toTime(destroyEndTime)} |`,
                `| **Duration** | ${duration} |`,
                "<br/>"
              ];

              commentBody.push("<br/>", "");
              commentBody.push("> [!NOTE]", "> The Destroy is completed. This request issue will be closing.");
              commentBody.push("<br/>", "<br/>",  "");
              const workflowTitle = context.workflow +" (" + context.runId + ")";
              const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
              commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

              const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
              
              const commentResponse = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: commentBody.join("\n")
              });
              console.log("for request form, commentResponse: ", commentResponse);
              const updateIssueResponse = await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: 'closed'
              });
              console.log("updateIssueResponse: ", updateIssueResponse);
              const lockIssueResponse = await github.rest.issues.lock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
              });
              console.log("issue is lock again, lock issue response:", lockIssueResponse);
              if(process.env.PR_NUMBER) {
                const prCommentResponse = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: process.env.PR_NUMBER,
                  body: commentBody.join("\n")
                });
                console.log("for PR, commentResponse: ", prCommentResponse);
              }
            } catch(error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during issue update for destroy completion, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  handle_failure:
    name: Handle Request form Failure
    runs-on: ubuntu-latest
    needs:
      - run_eligible
      - update_request
      - validate_request
      - validate_request_stack
      - create_tag
      - diff
      - deployment
      - destroy
    if: failure()
    steps:
      - run: |
          echo 'Run Eligible: ${{ needs.run_eligible }}'
          echo 'Update Request: ${{ needs.update_request }}'
          echo 'Validate Request: ${{ needs.validate_request }}'
          echo 'Validate Request Stack: ${{ needs.validate_request_stack }}'
          echo 'Create Tag: ${{ needs.create_tag }}'
          echo 'Diff: ${{ needs.diff }}'
          echo 'Deployment: ${{ needs.deployment }}'
          echo 'Destroy: ${{ needs.destroy }}'
      - if: needs.run_eligible.result == 'failure'
        run: |
          echo "Since run eligible job failed, skipping fail handler job"
          exit 1
      - id: prepare-error
        uses: actions/github-script@v7
        env:
          VALIDATION_FAIL_REASON: ${{ needs.update_request.outputs.failed-reason || needs.validate_request.outputs.failed-reason || needs.validate_request_stack.outputs.failed-reason }}
          IS_VALIDATION_FAILED: ${{ needs.update_request.result == 'failure' || needs.validate_request.result == 'failure' || needs.validate_request_stack.result == 'failure' || needs.diff.result == 'failure' }}
          DEPLOY_FAILED_REASON: ${{ needs.create_tag.outputs.failed-reason || needs.deployment.outputs.failed-reason }}
          IS_DEPLOY_FAILED: ${{ needs.deployment.result == 'failure' || needs.create_tag.result == 'failure' }}
          DESTROY_FAILED_REASON: ${{ needs.destroy.outputs.failed-reason }}
          IS_DESTROY_FAILED: ${{ needs.destroy.result == 'failure' }}
        with:
          script: |
            let errorDetails= "Found unknown error. Please check the logs.";
            if(String(process.env.IS_VALIDATION_FAILED) === "true") {
              errorDetails = process.env.VALIDATION_FAIL_REASON || errorDetails;
              core.setOutput("reason", "Validation of Api Request form is failed.");
              core.setOutput("status", "Denied");
            } else if(String(process.env.IS_DEPLOY_FAILED) === "true") {
              errorDetails = process.env.DEPLOY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Deployment of Infra stack is failed.");
              core.setOutput("status", "Failed");
            } else if(String(process.env.IS_DESTROY_FAILED) === "true") {
              errorDetails = process.env.DESTROY_FAILED_REASON || errorDetails;
              core.setOutput("reason", "Destroy of Infra Stack is failed.");
              core.setOutput("status", "Failed");
            } else {
              throw new Error("could not find any fail job");
            }
            core.setOutput("details", errorDetails);
      - name: Add Failed Reason as Comment
        uses: actions/github-script@v7
        env:
          FAIL_REASON: ${{ steps.prepare-error.outputs.reason }}
          ERROR_DETAILS: ${{ steps.prepare-error.outputs.details }}
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
        with:
          script: |
            const commentBody = [
                    "## Request " + process.env.FAIL_STATUS, 
                    "", "### Reason:", "",
                    "  " + process.env.FAIL_REASON, "",
                    "**Error:**  " + process.env.ERROR_DETAILS, 
                    "<br/>",  "",
                    "> [!NOTE]",
                    "> **Needs Action:**   Please raise a `new request form` with correct details. This request issue will be `closed`.",
                    "<br/>", "<br/>",  "",
                  ];
            const workflowTitle = context.workflow +" (" + context.runId + ")";
            const workflowLink = context.payload.repository.html_url+"/actions/runs/"+context.runId;
            commentBody.push("### Request Processed By: ", `  [Workflow - ${workflowTitle}](${workflowLink})`, "");

            console.log("commentRequest: ", {issue_number: context.payload.issue.number, body: commentBody});
            const unlockIssueResponse = await github.rest.issues.unlock({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number
            });
            console.log("issue is unlock temporarily, unlock issue response:", unlockIssueResponse);
            const commentResponse = github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: commentBody.join("\n")
            });
            console.log("commentResponse: ", commentResponse);
      - name: Close Issue
        uses: actions/github-script@v7
        env:
          FAIL_STATUS: ${{ steps.prepare-error.outputs.status }}
          ORIGINAL_ISSUE_TITLE: ${{ needs.run_eligible.outputs.original-issue-title }}
        with:
          script: |
            const closeUpdateResponse = await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              state: 'closed',
              title: "[" + process.env.FAIL_STATUS + "]" + process.env.ORIGINAL_ISSUE_TITLE,
            });
            console.log("closeUpdateResponse: ", closeUpdateResponse);
            const lockIssueResponse = await github.rest.issues.lock({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number
            });
            console.log("issue is lock again, lock issue response:", lockIssueResponse);
