# deploy or destroy UI stack when demanded. the on demand request is received from ui repository workflow
name: AWS UI Stack

on:
  repository_dispatch:
    types:
      - on-demand-ui-stack

concurrency:
  group: ${{ github.workflow }}-${{ github.event.client_payload.env_type }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

jobs:
  display_output:
    name: Print client payload of dispatch event
    runs-on: ubuntu-latest
    steps:
      - name: Print Client Payload
        run: |
          echo "Client Payload = ${{ toJson(github.event.client_payload) }}"
      - name: Print Github Context
        run: echo "github context json values = ${{ toJSON(github) }}"
      - name: Print Context
        uses: actions/github-script@v7
        with:
          script: |
            console.log("Context: ", context);

  validate_payload:
    name: Validate Client Payload
    runs-on: ubuntu-latest
    environment:
      name: aws-infra-${{ github.event.client_payload.env_type }}
    outputs:
      branch-name: ${{ steps.get-milestone-testplan.outputs.branchName || steps.get-milestone-prod.outputs.tagRefName }}
      failed-reason: ${{ steps.payload-schema.outputs.failedReason || steps.get-milestone-testplan.outputs.failedReason || steps.get-milestone-prod.outputs.failedReason }}
    steps:
      - name: Env Config
        run: |
          AWS_REGION="${{ vars.AWS_REGION }}"
          INFRA_ENV="${{ vars.INFRA_ENV }}"
          AWS_ROLE_ARN="${{ secrets.AWS_CICD_ROLE_ARN }}"
          if [ -z "$AWS_REGION" ] || [ -z "$INFRA_ENV" ] || [ -z "$AWS_ROLE_ARN" ]; then
            echo "One or more required environment variables are not set."
            exit 1
          fi
      - id: payload-schema
        name: Payload Schema
        uses: actions/github-script@v7
        with:
          script: |
            const payload = context.payload.client_payload;
            const errors = [];
            if(!Array.isArray(payload.stack_tags)) {
              errors.push("stack tags is not array.");
            }
            if(payload.type !== "provision" && payload.type !== "deprovision") {
              errors.push("request type is not supported.");
            }
            if(!payload.milestone) {
              errors.push("milestone is not provided");
            }
            if(!payload.ui_repository) {
              errors.push("ui_repository is not provided");
            }
            if(!payload.ui_repository.startsWith(context.repo.owner)) {
              errors.push("ui_repository owner is not correct");
            }
            if(!payload.workflow_run_id) {
              errors.push("workflow_run_id is not provided");
            }
            if(!payload.artifact_name) {
              errors.push("artifact_name is not provided");
            }
            if(errors.length>0) {
              const failedMessage = "client payload schema invalid. errors: [" + errors.join(",") + "]";
              core.setOutput("failedReason", failedMessage);
              core.setFailed(failedMessage);
            }
      - name: Checkout
        uses: actions/checkout@v4
      - id: get-milestone-testplan
        if: github.event.client_payload.is_testplan == 'true'
        name: Validate Milestone and Branch
        uses: actions/github-script@v7
        with:
          script: |
            try {
              var branchName = "master";
              if(context.payload.client_payload.apiVersion) {
                // get milestone
                const listMilestonesResponse = await github.rest.issues.listMilestones({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "all"
                });
                console.log("listMilestonesResponse=", listMilestonesResponse);
                const matchedMilestone = listMilestonesResponse.data.find(mlst=>mlst.title===context.payload.client_payload.apiVersion);
                if(!matchedMilestone) {
                  throw Error(`milestone for matching api version[${context.payload.client_payload.apiVersion}] not found.`);
                }
                if(matchedMilestone.state === "open") {
                  // check milestone branch
                  if(!matchedMilestone.due_on) {
                    throw new Error("Milestone due date is not set");
                  }
                  const milestoneDueOn = new Date(matchedMilestone.due_on);
                  if(milestoneDueOn < new Date()) {
                    throw new Error("Milestone due date is already passed");
                  }
                  branchName = `milestone/${matchedMilestone.title}`;
                }
              }
              if(branchName!=="master") {
                // verify milestone branch commit has merged all of the master branch
                const compareResponse = await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: "master",
                  head: branchName
                });
                console.log("milestone branch as head and master branch as base, compareResponse: ", compareResponse);
                if (compareResponse.data.behind_by > 0) {
                  throw new Error(`Milestone branch [${branchName}] is behind master by ${compareResponse.data.behind_by} commits.`);
                }
              } else {
                // The master branch should have api version, old versions deployment is not supported
                // compare package.json and milestone version
                const fs = require('fs');
                const packageJson = fs.readFileSync('package.json', 'utf8');
                const packageJsonObj = JSON.parse(packageJson);
                if(`v${packageJsonObj.version}` !== context.payload.client_payload.apiVersion) {
                  throw new Error(`Master branch package.json version [${packageJsonObj.version}] does not match with requested version [${context.payload.client_payload.apiVersion}]`);
                }
              }
              core.setOutput("branchName", branchName);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }
      - name: Setup Node Latest
        # https://github.com/actions/setup-node
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - run: |
          npm install @aws-sdk/client-cloudformation
      - name: AWS Access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: get-milestone-prod
        name: Validate Milestone and Branch
        if: github.event.client_payload.is_prod == 'true'
        uses: actions/github-script@v7
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
        with:
          script: |
            try {
              const { CloudFormationClient, DescribeStacksCommand } = require("@aws-sdk/client-cloudformation");
              // Initialize CloudFormation client
              // https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/cloudformation/command/DescribeStacksCommand/
              const cloudFormationClient = new CloudFormationClient();
              const stackSuccessRegex = new RegExp("^CREATE_COMPLETE|UPDATE_COMPLETE$");
              const describeStackCommand = new DescribeStacksCommand({ StackName: `prsfin-${process.env.INFRA_ENV}-infra-stack` });
              const describeStackResponse = await cloudFormationClient.send(describeStackCommand);
              console.log("describeStackResponse:", describeStackResponse);
              // check status
              if(!stackSuccessRegex.test(describeStackResponse.Stacks[0].StackStatus)) {
                throw new Error(`Infra Stack deployment is not success. found undesired Status [${describeStackResponse.StackStatus}] with reason, ${describeStackResponse.StackStatusReason}. Please check stack events for more details.`);
              }
              // find latest deployed tag
              const milestoneTag = describeStackResponse.Stacks[0].Tags.find(tag=>tag.Key==="milestone");
              if(!milestoneTag?.Value) {
                throw new Error("deployed version not found");
              }
              const getRefResponse = await github.rest.repos.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${milestoneTag.Value}`
              });
              console.log("getRefResponse: ", getRefResponse);
              core.setOutput("tagRefName", tagRef.ref);
            } catch (error) {
              console.error("failed reason: ", error);
              core.setOutput("failedReason", `Error during milestone validation, reason: ${error.message}`);
              core.setFailed(error.message);
            }

  validate_deployment:
    name: Validate deployment
    runs-on: ubuntu-latest
    needs:
      - validate_payload
    if: github.event.client_payload.type == 'provision'
    environment:
      name: aws-infra-${{ github.event.client_payload.env_type }}
    outputs:
      failed-reason: ${{ steps.validate-uistack-status.outputs.failedReason }}
    steps:
      - run: mkdir -p dist/ui
      - name: download UI artifact
        uses: actions/download-artifact@v4
        with:
          path: dist/ui/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.event.client_payload.ui_repository }}
          run-id: ${{ github.event.client_payload.workflow_run_id }}
          name: ${{ github.event.client_payload.artifact_name }}
      - name: Copy artifact files to UI asset directory
        run: |
          pwd
          echo ls -lrt
          ls -lrt
          echo ls -lrt dist
          ls -lrt dist
          # echo ls -lrt dist/$ARTIFACT_NAME
          # ls -lrt dist/$ARTIFACT_NAME
          # echo "copying artifact folder to ui"
          # cp -r dist/$ARTIFACT_NAME/* dist/ui
        env:
          ARTIFACT_NAME: ${{ github.event.client_payload.artifact_name }}
      - name: validate UI asset directory structure
        run: |
          echo ls -lrt dist
          ls -lrt dist
          echo ls -lrt dist/ui
          ls -lrt dist/ui
          ls -lrt dist/ui/index.html
          ls -lrt dist/ui/logo.jpeg
          ls -lrt dist/ui/logo192.png
          ls -lrt dist/ui/favicon.ico
          echo ls -lrt dist/ui/static
          ls -lrt dist/ui/static
          echo ls -lrt dist/ui/static/css
          ls -lrt dist/ui/static/css
          echo ls -lrt dist/ui/static/js
          ls -lrt dist/ui/static/js
          echo ls -lrt dist/ui/static/media
          ls -lrt dist/ui/static/media
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: Validate UI stack status
        id: validate-uistack-status
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          MILESTONE_TITLE: ${{ github.event.client_payload.milestone }}
          IS_TESTPLAN: ${{ github.event.client_payload.is_testplan }}
        run: |
          FAILED_REASON=""
          UI_STACK_NAME="prsfin-$INFRA_ENV-ui-deploy-stack"
          set +e
          DESCRIBE_UI_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$UI_STACK_NAME")
          RET_CODE=$?
          set -e
          if [[ $RET_CODE -ne 0 ]]; then
            echo "UI Stack does not exist. given branch for milestone can be deployed."
            exit 0
          fi
          # verify stack status
          STACK_STATUS=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
          if [[ ! "$STACK_STATUS" =~ _COMPLETE$ ]]; then
            STACK_STATUS_REASON=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
            FAILED_REASON="The system cannot start UI deployment, because the Stack status is not complete, found Status: $STACK_STATUS. The Stack Status Reason: $STACK_STATUS_REASON"
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          # environment tag match must never fail
          TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="environment").Value')
          if [[ "$TAG_VALUE" != "$INFRA_ENV" ]]; then
            FAILED_REASON="Stack is deployed for other environment $TAG_VALUE stack."
            echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
            echo "Failed Reason: $FAILED_REASON"
            exit 1
          fi
          if [[ "$IS_TESTPLAN" == "true" ]]; then
            # check milestone 
            TAG_VALUE=$(echo "$DESCRIBE_UI_STACK_OUT" | jq -r '.Stacks[0].Tags[] | select(.Key=="milestone").Value')
            if [[ "$TAG_VALUE" != "$MILESTONE_TITLE" ]]; then
              FAILED_REASON="Other milestone branch is deployed to Test plan environment. Wait for completion of $TAG_VALUE tests."
              echo "failedReason=$FAILED_REASON" >> $GITHUB_OUTPUT
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi
          fi

  diff_stack:
    name: UI stack diff
    runs-on: ubuntu-latest
    needs:
      - validate_payload
      - validate_deployment
    environment:
      name: aws-infra-${{ github.event.client_payload.env_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_payload.outputs.branch-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - run: |
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          mkdir -p dist/ui
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: cdk diff
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "diff"
          actions_comment: false
          cdk_args: "MyFinanceUiDeployStack"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ join(github.event.client_payload.stack_tags, ',') }}

  wait_infra_deploy:
    name: Wait for Infra Stack deployment
    runs-on: ubuntu-latest
    needs:
      - validate_deployment
    environment:
      name: aws-infra-${{ github.event.client_payload.env_type }}
    outputs:
      distribution-id: ${{ steps.wait-stack.outputs.distribution_id }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - id: wait-stack
        name: Wait for Stack Completion
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
        run: |
          # Wait duration to execute the command and check status 
          SLEEP_DURATION=30 # 30 sec
          TOTAL_WAIT_DURATION=1800 # 30 min=30*60
          REMAINING_ATTEMPTS=$((TOTAL_WAIT_DURATION / SLEEP_DURATION))
          API_STACK_NAME="prsfin-$INFRA_ENV-infra-stack"
          echo "initial wait for 5 min, assuming request is submitted for api stack and is getting processed"
          sleep 300
          while [[ $REMAINING_ATTEMPTS -gt 0 ]]; do
            echo "Deployment is in progress. Waiting for $SLEEP_DURATION."
            sleep $SLEEP_DURATION
            REMAINING_ATTEMPTS=$((REMAINING_ATTEMPTS - 1))
            set +e
            DESCRIBE_API_STACK_OUT=$(aws cloudformation describe-stacks --stack-name "$API_STACK_NAME")
            RET_CODE=$?
            set -e
            if [[ $RET_CODE -ne 0 ]]; then
              echo "Describe Stack failed with exit code, $RET_CODE. Will wait more"
              continue
            fi
            # verify stack status
            STACK_STATUS=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].StackStatus')
            if [[ "$STACK_STATUS" =~ _COMPLETE$ ]]; then
              echo "Infra Api Stack deployment is complete."
              break
            fi
            if [[ "$STACK_STATUS" =~ ^(CREATE_FAILED|UPDATE_FAILED|ROLLBACK.*|UPDATE_ROLLBACK.*|DELETE.*)$ ]]; then
              STACK_STATUS_REASON=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].StackStatusReason')
              FAILED_REASON="Infra Api Stack deployment failed. Stack status is $STACK_STATUS. Stack Reason: $STACK_STATUS_REASON Please check logs for more details."
              echo "Failed Reason: $FAILED_REASON"
              exit 1
            fi
          done

          if [[ $RET_CODE -ne 0 ]]; then
            echo "Infra Api Stack deployment is not started."
            exit 1
          fi
          if [[ ! "$STACK_STATUS" =~ _COMPLETE$ ]]; then
            echo "Infra Api Stack deployment is taking longer time than expected. please validate stack manually"
            exit 1
          fi
          DISTRIBUTION_ID=$(echo "$DESCRIBE_API_STACK_OUT" | jq -r '.Stacks[0].Outputs[] | select(.OutputKey[0:14] == "DistributionId").OutputValue')
          echo "distribution_id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT

  deployment:
    name: deploy UI stack
    runs-on: ubuntu-latest
    needs:
      - validate_payload
      - diff_stack
      - wait_infra_deploy
    environment:
      name: aws-infra-${{ github.event.client_payload.env_type }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate_payload.outputs.branch-name }}
      - name: Setup Node Latest
        uses: actions/setup-node@v4
        with:
          node-version: "latest"
          cache: "npm"
      - run: |
          npm --version
          npm ci
          npm run build
          mkdir -p dist/lambda_layer/nodejs
          mkdir -p dist/ui
      - name: download UI artifact
        uses: actions/download-artifact@v4
        with:
          path: dist/ui/
          github-token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.event.client_payload.ui_repository }}
          run-id: ${{ github.event.client_payload.workflow_run_id }}
          name: ${{ github.event.client_payload.artifact_name }}
      # - run: ls -lrt dist/${{ github.event.client_payload.artifact_name }}
      - run: |
          # cp -r dist/$ARTIFACT_NAME/* dist/ui
          ls -lrt dist/ui
        env:
          ARTIFACT_NAME: ${{ github.event.client_payload.artifact_name }}
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          # setup cicd role through instructions from aws-manual branch.
          role-to-assume: ${{ secrets.AWS_CICD_ROLE_ARN }}
          role-session-name: cdkSession
      - name: cdk deploy
        uses: youyo/aws-cdk-github-actions@v2
        with:
          cdk_subcommand: "deploy"
          actions_comment: false
          debug_log: true
          cdk_stack: "MyFinanceUiDeployStack"
          cdk_args: "--require-approval never --exclusively"
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          TAGS: ${{ join(github.event.client_payload.stack_tags, ',') }}
      - name: Invalidate old UI Cf cache
        env:
          INFRA_ENV: ${{ vars.INFRA_ENV }}
          DISTRIBUTION_ID: ${{ needs.wait_infra_deploy.outputs.distribution-id }}
          UI_BASE_PATH: ${{ vars.UI_BASE_PATH }}
        run: |
          echo aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "$UI_BASE_PATH/index.html" --query "Invalidation.Id" --output text
          INVALIDATION_ID=$(aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "$UI_BASE_PATH/index.html" --query "Invalidation.Id" --output text)
          echo Invalidation Id = $INVALIDATION_ID
          INVALIDATION_STATUS="inprogress"
          SLEEP_DURATION=30
          until [ "$INVALIDATION_STATUS" == "Completed" ]; do
            echo "sleeping $SLEEP_DURATION sec since cf cache hasn't been invalidated"
            sleep $SLEEP_DURATION
            echo aws cloudfront get-invalidation --id $INVALIDATION_ID --distribution-id $DISTRIBUTION_ID --query "Invalidation.Status" --output text
            INVALIDATION_STATUS=$(aws cloudfront get-invalidation --id $INVALIDATION_ID --distribution-id $DISTRIBUTION_ID --query "Invalidation.Status" --output text)
            echo "Invalidation Status: $INVALIDATION_STATUS"
          done
          echo "The task, to invalidate cache for index.html, is now completed."
